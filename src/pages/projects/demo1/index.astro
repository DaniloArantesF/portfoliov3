---
import StealthLayout from '../../../layouts/StealthLayout.astro';
---

<StealthLayout title="Demo 1">
  <main>
    <canvas id="app_view"></canvas>
    <div id="gui_container"></div>
  </main>
</StealthLayout>

<script>
  import * as THREE from 'three';
  import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
  import vertexShader from './shaders/vertex.vs.glsl?raw';
  import fragmentShader from './shaders/fragment.fs.glsl?raw';
  import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
  import * as dat from 'dat.gui';

  /* ---------------------------------------------- */
  /*                   Constants                    */
  /* ---------------------------------------------- */
  const ORBIT_CONTROLS = true;

  const App = () => {
    /* ---------------------------------------------- */
    /*                    Graphics                    */
    /* ---------------------------------------------- */
    const canvas = document.querySelector('#app_view') as HTMLCanvasElement;
    let camera: THREE.PerspectiveCamera,
      scene: THREE.Scene,
      renderer: THREE.WebGLRenderer,
      composer: EffectComposer,
      renderScene: RenderPass;

    /* ---------------------------------------------- */
    /*                    Settings                    */
    /* ---------------------------------------------- */
    let gui: dat.GUI;
    const settings = {
      test: 1,
    };
    let controls: OrbitControls, clock: THREE.Clock, time: number;
    let cameraPole: THREE.Object3D, gridHelper: THREE.GridHelper;
    const fov = 75;
    const aspect = window.innerWidth / window.innerHeight;
    const near = 0.1;
    const far = 1000;
    const uniforms = {
      uResolution: {
        value: new THREE.Vector2(window.innerWidth, window.innerHeight),
        type: 'v2',
      },
      uTime: {
        type: 'f',
        value: 0.0,
      },
      uMouse: { value: { x: 0, y: 0 } },
      uTest: { value: 1 },
    };

    function init() {
      scene = new THREE.Scene();
      renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: true,
      });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);

      composer = new EffectComposer(renderer);
      clock = new THREE.Clock();

      initScene();
      initGUI();
      postProcessing();
      render();
    }

    function initScene() {
      /* --------- Camera --------- */
      camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      camera.position.set(0, 5, 20);

      cameraPole = new THREE.Object3D();
      scene.add(cameraPole);
      cameraPole.add(camera);

      /* ---------- Utils ---------- */
      if (ORBIT_CONTROLS) {
        controls = new OrbitControls(camera, renderer.domElement);
      }
      gridHelper = new THREE.GridHelper(200, 50);
      scene.add(gridHelper);

      /* ---------- Geometry ---------- */
      const geometry = new THREE.SphereGeometry(20, 100, 100);
      const material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        wireframe: true,
        vertexShader,
        fragmentShader,
      });

      const mesh = new THREE.Points(geometry, material);

      mesh.position.set(0, 10, 0);
      mesh.rotateX(Math.PI * 2);
      scene.add(mesh);

      /* ---------- Events ---------- */
      canvas.addEventListener('mousemove', (event) => {
        uniforms.uMouse.value.x = (event.clientX - window.innerWidth / 2) * 0.1;
        uniforms.uMouse.value.y =
          (event.clientY - window.innerHeight / 2) * 0.08;
      });

      window.addEventListener('resize', () => {
        uniforms.uResolution.value = new THREE.Vector2(
          window.innerWidth,
          window.innerHeight,
        );
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
        camera.position.set(0, 40, 40);
      });
    }

    function initGUI() {
      gui = new dat.GUI({ autoPlace: false });
      gui.width = 300;
      gui.domElement.id = 'gui';
      document.getElementById('gui_container')!.append(gui.domElement);

      gui
        .add(settings, 'test', 0, 1, 0.01)
        .name('Test Value')
        .onChange(() => {
          uniforms.uTest.value = settings.test;
        });
    }

    function render() {
      requestAnimationFrame(render);

      time = clock.getElapsedTime();

      // update uniforms
      uniforms.uTime.value = time;

      if (ORBIT_CONTROLS) {
        controls.update();
      } else {
        camera.position.x +=
          (uniforms.uMouse.value.x - camera.position.x) * 0.05;
        camera.position.y +=
          (-uniforms.uMouse.value.y - camera.position.y) * 0.05;
        camera.lookAt(scene.position);
      }
      composer.render();
    }

    function postProcessing() {
      renderScene = new RenderPass(scene, camera);
      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.5,
        0.5,
        0.6,
      );

      composer.addPass(bloomPass);
      composer.addPass(renderScene);
    }

    init();
  };

  App();
</script>

<style is:global>
  html {
    height: 100vh;
    overflow: hidden;
  }
</style>

<style>
  body {
    width: 100%;
    height: 100vh;
    background: var(--color-background);
    overflow: hidden;
    overscroll-behavior: none;
    margin: 0;
    padding: 0;
  }

  #app_view {
    display: block;
    width: 100%;
    height: 100%;
  }

  #gui_container {
    position: absolute;
    bottom: 2rem;
    left: 50%;
    transform: translateX(-50%);
    background: red;
  }

  #gui {
    position: absolute;
    top: 0;
    left: 0;
  }
</style>
