---
import SceneLayout from 'src/layouts/SceneLayout.astro';
---

<SceneLayout title="Boids" />

<script>
  import * as THREE from 'three';
  import BaseScene, { BaseSceneState, isReady } from '@lib/sceneController';
  import { rand } from '@utils/math';
  import SpatialGrid from '@lib/SpatialGrid';
  import { createDebugBounds } from '@lib/helpers';

  const canvas = document.getElementById('app_view')! as HTMLCanvasElement;
  const { state, registerRenderCallback, unregisterRenderCallback } = BaseScene(
    { canvas, settings: { cameraPosition: [0, 0, 100], orbitControls: true } },
  );
  const { scene, renderer, camera, uniforms } = state;

  const BOUNDS = { width: 100, height: 100, depth: 100 };
  const NUM_BOIDS = 100;
  const BOID_SPEED = 3.5;
  const BOID_ACCELERATION = BOID_SPEED / 2.5;
  const BOID_FORCE_MAX = BOID_ACCELERATION / 10.0;
  const BOID_FORCE_ORIGIN = 8;
  const BOID_FORCE_ALIGNMENT = 10;
  const BOID_FORCE_SEPARATION = 20;
  const BOID_FORCE_COHESION = 10;
  const BOID_FORCE_WANDER = 3;

  const SPEED_MIN = 3;
  const SPEED_MAX = 4;

  const boids: Boid[] = [];

  interface BoidParams {
    speedMin: number;
    speedMax: number;
    speed: number;
    maxSteeringForce: number;
    acceleration: number;
    color: number;
  }

  const hashGrid = new SpatialGrid<Boid>({
    bounds: [
      new THREE.Vector3(-BOUNDS.width / 2, 0, -BOUNDS.depth / 2),
      new THREE.Vector3(BOUNDS.width / 2, 0, BOUNDS.depth / 2),
    ],
    dimensions: [10, 10],
  });

  class Boid {
    public mesh: THREE.Mesh;
    public readonly group: THREE.Group;
    public position: THREE.Vector3;
    public direction: THREE.Vector3;
    public velocity: THREE.Vector3;
    private maxSteeringForce: number;
    private maxSpeed: number;
    public acceleration: number;
    public radius: number; // (used for collision detection)
    private wanderAngle: number;
    public hashPosition: [number, number]; // cur index of hash grid
    // maybe add prev position ?

    constructor({
      speedMin,
      speedMax,
      speed,
      maxSteeringForce,
      acceleration,
      color,
    }: BoidParams) {
      // Initialize boid, give it a random initial position and direction
      this.mesh = new THREE.Mesh(
        new THREE.ConeGeometry(1, speed * 2, 10, 10),
        new THREE.MeshBasicMaterial({ color }),
      );
      this.position = new THREE.Vector3(
        rand(-BOUNDS.width / 2, BOUNDS.width / 2),
        rand(-BOUNDS.height / 4, BOUNDS.height / 4),
        rand(-BOUNDS.depth / 2, BOUNDS.depth / 2),
      );

      this.group = new THREE.Group();
      this.group.add(this.mesh);
      this.group.position.set(
        this.position.x,
        this.position.y,
        this.position.z,
      );

      this.direction = new THREE.Vector3(rand(-1, 1), 0, rand(-1, 1));
      this.velocity = this.direction.clone();

      // Calculate the boid's speed and scale based on the provided parameters
      const speedMultiplier = rand(speedMin, speedMax);
      this.maxSteeringForce = maxSteeringForce * speedMultiplier;
      this.maxSpeed = speed * speedMultiplier;
      this.acceleration = acceleration * speedMultiplier;
      this.wanderAngle = 0;

      // Scale down based on speed multiplier
      const scale = 1.0 / speedMultiplier;
      this.radius = scale;
      this.mesh.scale.setScalar(scale);
      this.mesh.rotateX(-Math.PI / 2);

      scene.add(this.group);
      this.hashPosition = hashGrid.updateEntityPosition(this.group.uuid, this);
    }

    // Applies steering behavior and updates direction/velocity
    step(timeSeconds: number) {
      this.applySteering();

      const frameVelocity = this.velocity.clone();
      frameVelocity.multiplyScalar(timeSeconds);
      this.group.position.add(frameVelocity);
      this.position = this.group.position;

      const direction = this.direction;
      const m = new THREE.Matrix4();
      m.lookAt(
        new THREE.Vector3(0, 0, 0),
        direction,
        new THREE.Vector3(0, 1, 0),
      );
      this.group.quaternion.setFromRotationMatrix(m);

      // Update hash grid
      this.hashPosition = hashGrid.updateEntityPosition(
        this.group.uuid,
        this,
        this.hashPosition,
      );
    }

    // Applies steering behaviors
    applySteering() {
      this.avoidWalls();
    }

    // Calculates desired separation, steer it away if it gets too close
    applySeparation() {}

    // Calculates average heading of neighbors and steer towards it
    applyAlignment() {}

    // Calculates average position of neighbors and steer towards it
    applyCohesion() {}

    applyGroupAvoidance() {}
    applyWander() {}
    applySeek() {}

    avoidWalls() {
      const position = this.group.position.clone();
      if (position.x <= -BOUNDS.width / 2 || position.x >= BOUNDS.width / 2) {
        this.direction.x = -this.direction.x;
        this.velocity = this.direction.clone();
      }

      if (position.z < -BOUNDS.depth / 2 || position.z > BOUNDS.depth / 2) {
        this.direction.z = -this.direction.z;
        this.velocity = this.direction.clone();
      }

      if (position.y < -BOUNDS.height / 2 || position.y > BOUNDS.height / 2) {
        this.direction.y = -this.direction.y;
        this.velocity = this.direction.clone();
      }
    }
  }

  class BoidLeader extends Boid {
    public influenceRadius: number;

    constructor(params: BoidParams) {
      super(params);
      this.group.position.set(0, 0, 0);
      this.position = this.group.position;
      this.influenceRadius = 15;
      this.hashPosition = hashGrid.updateEntityPosition(
        this.group.uuid,
        this,
        this.hashPosition,
      );
      this.debug();
    }

    debug() {
      const wireframe = new THREE.WireframeGeometry(
        new THREE.SphereGeometry(this.influenceRadius),
      );

      const helper = new THREE.LineSegments(wireframe);
      (helper.material as THREE.Material).depthTest = false;
      (helper.material as THREE.Material).opacity = 0.25;
      (helper.material as THREE.Material).transparent = true;

      this.group.add(helper);
    }
  }

  function createBoids() {
    for (let i = 0; i < NUM_BOIDS; i++) {
      const f = new Boid({
        speedMin: 3.0,
        speedMax: 4.0,
        speed: BOID_SPEED,
        maxSteeringForce: BOID_FORCE_MAX,
        acceleration: BOID_ACCELERATION,
        color: 0xc4c4c4,
      });
      boids.push(f);
    }

    // Create leader
    const leader = new BoidLeader({
      speedMin: 3.0,
      speedMax: 4.0,
      speed: BOID_SPEED,
      maxSteeringForce: BOID_FORCE_MAX,
      acceleration: BOID_ACCELERATION,
      color: 0xff0000,
    });

    boids.push(leader);
  }

  createBoids();
  const helper = createDebugBounds([BOUNDS.width, BOUNDS.height, BOUNDS.depth]);
  scene.add(helper);
  const timeMultiplier = 0.001;
  const leader = boids[boids.length - 1] as BoidLeader;
  let localEntities: Boid[] = [];

  function animationLoop({ time }: BaseSceneState) {
    for (let i = 0; i < boids.length; i++) {
      let isLocal =
        localEntities.findIndex((b) => b.group.uuid === boids[i].group.uuid) !==
        -1;
      let isLeader = boids[i] instanceof BoidLeader;

      if (
        !isLeader &&
        (boids[i].mesh.material as THREE.MeshBasicMaterial).color.g === 1 &&
        !isLocal
      ) {
        (boids[i].mesh.material as THREE.MeshBasicMaterial).color.setHex(
          0xc4c4c4,
        );
      }

      if (isLocal) {
        (boids[i].mesh.material as THREE.MeshBasicMaterial).color.set(0x00ff00);
      }
      boids[i].step(time * timeMultiplier);
    }

    // Update local for next frame
    localEntities = hashGrid.getLocalEntities(
      leader.position,
      leader.influenceRadius,
    );
  }

  registerRenderCallback(animationLoop);
  isReady.set(true);
</script>
