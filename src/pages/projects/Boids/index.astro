---
import SceneLayout from 'src/layouts/SceneLayout.astro';
---

<SceneLayout title="Fireflies" />

<script>
  import * as THREE from 'three';
  import BaseScene, { BaseSceneState, isReady } from '@lib/sceneController';
  import { rand } from '@utils/math';

  const canvas = document.getElementById('app_view')! as HTMLCanvasElement;
  const { state, registerRenderCallback, unregisterRenderCallback } = BaseScene(
    { canvas, settings: { cameraPosition: [0, 0, 100], orbitControls: true } },
  );
  const { scene, renderer, camera, uniforms } = state;

  const BOUNDS = { width: 100, height: 100, depth: 100 };
  const NUM_BOIDS = 50;
  const BOID_SPEED = 2.5;
  const BOID_ACCELERATION = BOID_SPEED / 5.0;
  const BOID_FORCE_MAX = BOID_ACCELERATION / 10.0;
  const BOID_FORCE_ORIGIN = 8;
  const BOID_FORCE_ALIGNMENT = 10;
  const BOID_FORCE_SEPARATION = 20;
  const BOID_FORCE_COHESION = 10;
  const BOID_FORCE_WANDER = 3;

  const SPEED_MIN = 3;
  const SPEED_MAX = 4;

  const fireflies: Firefly[] = [];

  interface FireflyParams {
    speedMin: number;
    speedMax: number;
    speed: number;
    maxSteeringForce: number;
    acceleration: number;
    color: number;
  }

  class Firefly {
    private mesh: THREE.Mesh;
    private group: THREE.Group;
    private position: THREE.Vector3;
    private direction: THREE.Vector3;
    private velocity: THREE.Vector3;

    // Boid settings
    private maxSteeringForce: number;
    private maxSpeed: number;
    private acceleration: number;
    private radius: number; // (used for collision detection)
    private wanderAngle: number;

    constructor({
      speedMin,
      speedMax,
      speed,
      maxSteeringForce,
      acceleration,
      color,
    }: FireflyParams) {
      this.mesh = new THREE.Mesh(
        new THREE.ConeGeometry(1, speed * 2, 10, 10),
        new THREE.MeshBasicMaterial({ color }),
      );
      this.position = new THREE.Vector3(
        rand(-50, 50),
        rand(1, 25),
        rand(-50, 50),
      );

      this.group = new THREE.Group();
      this.group.add(this.mesh);
      this.group.position.set(
        this.position.x,
        this.position.y,
        this.position.z,
      );

      this.direction = new THREE.Vector3(rand(-1, 1), 0, rand(-1, 1));
      this.velocity = this.direction.clone();

      // Calculate the boid's speed and scale based on the provided parameters
      const speedMultiplier = rand(speedMin, speedMax);
      this.maxSteeringForce = maxSteeringForce * speedMultiplier;
      this.maxSpeed = speed * speedMultiplier;
      this.acceleration = acceleration * speedMultiplier;
      this.wanderAngle = 0;

      // Scale down based on speed multiplier
      const scale = 1.0 / speedMultiplier;
      this.radius = scale;
      this.mesh.scale.setScalar(scale);
      this.mesh.rotateX(-Math.PI / 2);

      scene.add(this.group);
    }

    step(timeSeconds: number) {
      // Apply steering behavior
      this.avoidWalls();

      // Update velocity
      const frameVelocity = this.velocity.clone();
      frameVelocity.multiplyScalar(timeSeconds);
      this.group.position.add(frameVelocity);

      // Update direction
      const direction = this.direction;
      const m = new THREE.Matrix4();
      m.lookAt(
        new THREE.Vector3(0, 0, 0),
        direction,
        new THREE.Vector3(0, 1, 0),
      );
      this.group.quaternion.setFromRotationMatrix(m);
    }

    applySteering() {}

    applyGroupAvoidance() {}

    applyWander() {}

    applySeparation() {}

    applyAlignment() {}

    applyCohesion() {}

    applySeek() {}

    avoidWalls() {
      const position = this.group.position.clone(); //.addScalar(this.radius);
      if (position.x <= -BOUNDS.width / 2 || position.x >= BOUNDS.width / 2) {
        this.direction.x = -this.direction.x;
        this.velocity = this.direction.clone();
      }

      if (position.z < -BOUNDS.depth / 2 || position.z > BOUNDS.depth / 2) {
        this.direction.z = -this.direction.z;
        this.velocity = this.direction.clone();
      }

      if (position.y < -BOUNDS.height / 2 || position.y > BOUNDS.height / 2) {
        this.direction.y = -this.direction.y;
        this.velocity = this.direction.clone();
      }
    }
  }

  function createFireflies() {
    for (let i = 0; i < NUM_BOIDS; i++) {
      const f = new Firefly({
        speedMin: 3.0,
        speedMax: 4.0,
        speed: BOID_SPEED,
        maxSteeringForce: BOID_FORCE_MAX,
        acceleration: BOID_ACCELERATION,
        color: 0xff0000,
      });
      fireflies.push(f);
    }
  }

  function createDebugBounds() {
    const box = new THREE.Box3();
    box.setFromCenterAndSize(
      new THREE.Vector3(0, 0, 0),
      new THREE.Vector3(100, 100, 100),
    );

    const helper = new THREE.Box3Helper(box, new THREE.Color(0.5, 0.5, 0.5));
    scene.add(helper);
  }

  function animationLoop({ time }: BaseSceneState) {
    for (let i = 0; i < fireflies.length; i++) {
      fireflies[i].step(time * 0.001);
    }
  }

  createFireflies();
  createDebugBounds();
  registerRenderCallback(animationLoop);
  isReady.set(true);
</script>

<style>

</style>
