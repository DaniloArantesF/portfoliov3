---
import SceneLayout from 'src/layouts/SceneLayout.astro';

const title = 'Embers';
---

<SceneLayout title={title} audio />

<script>
  import * as THREE from 'three';
  import BaseScene, { isReady } from '@lib/sceneController';
  import vertexShader from './shaders/vertex.vs.glsl';
  import fragmentShader from './shaders/fragment.fs.glsl';
  import positionFragment from './shaders/position.fs.glsl';
  import heatPassVertexShader from './shaders/heatPass.vs.glsl';
  import heatPassFragmentShader from './shaders/heatPass.fs.glsl';
  import { usePlayer } from '~/components/Player';
  import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass';
  import {
    GPUComputationRenderer,
    Variable,
  } from 'three/examples/jsm/misc/GPUComputationRenderer';

  const SIMULATION_WIDTH = 32;

  /* -------------------------------- */
  /*          Setup & Globals         */
  /* -------------------------------- */
  const canvas = document.getElementById('app-view')! as HTMLCanvasElement;
  const { state, registerRenderCallback, setSceneHook, utils } = BaseScene({
    canvas,
    settings: {
      orbitControls: true,
      cameraPosition: [0, 0, 5],
      antialias: true,
    },
  });
  const { scene, camera, renderer, composer } = state;

  /* ---------- Audio ---------- */
  let player = usePlayer.get();

  /* -------------------------------- */
  /*                Scene             */
  /* -------------------------------- */
  function Scene() {
    let mesh: THREE.Points,
      material: THREE.ShaderMaterial,
      geometry: THREE.BufferGeometry;

    let heatPass: ShaderPass;
    let gpuCompute: GPUComputationRenderer;
    let dtPosition: THREE.DataTexture;
    let positionVariable: Variable;

    let spotLight: THREE.SpotLight;

    const loadedAudioState = {
      value: 0,
      maxValue: 0,
    };

    const settings = {
      cameraPosition: [0, 0, 5],
      bloomStrength: 1.5,
      bloomThreshold: 0.1,
      bloomRadius: 0.1,
    };

    const uniforms = {
      ...state.uniforms,
      positionTexture: { value: null },
      fft: { value: 0.0 },
    };

    function handleEvents() {
      // Handle resize
      setSceneHook('onResize', () => {
        const resolution = new THREE.Vector2(
          window.innerWidth,
          window.innerHeight,
        );
        heatPass.uniforms.uResolution.value = resolution;
        utils.updateSetting('cameraPosition', settings.cameraPosition);
        utils.resetCamera();
      });
    }

    function animationLoop() {
      gpuCompute.compute();
      material.uniforms.positionTexture.value =
        gpuCompute.getCurrentRenderTarget(positionVariable).texture;

      if (player.analyser) {
        player.analyser.getByteFrequencyData(player.buffer);
        const averageFrequency =
          player.buffer.reduce((a, b) => a + b, 0) / player.buffer.length;

        loadedAudioState.value = averageFrequency;

        // Update max fft value
        loadedAudioState.maxValue = Math.max(
          loadedAudioState.value,
          loadedAudioState.maxValue || 1,
        );

        // Normalize fft value
        (mesh.material as THREE.ShaderMaterial).uniforms.fft.value =
          loadedAudioState.value / loadedAudioState.maxValue;
      }
      // spotLight.rotation.y += 0.01;
    }

    function initGPGPU() {
      gpuCompute = new GPUComputationRenderer(
        SIMULATION_WIDTH,
        SIMULATION_WIDTH,
        renderer,
      );

      dtPosition = gpuCompute.createTexture();

      fillPositions(dtPosition);

      positionVariable = gpuCompute.addVariable(
        'texturePosition',
        positionFragment,
        dtPosition,
      );

      // Add variable uniforms
      positionVariable.material.uniforms = uniforms;

      positionVariable.wrapS = THREE.RepeatWrapping;
      positionVariable.wrapT = THREE.RepeatWrapping;

      gpuCompute.init();
    }

    function fillPositions(texture: THREE.DataTexture) {
      let data = texture.image.data;
      let radius = 5;

      for (let i = 0; i < data.length; i += 4) {
        const phi = Math.random() * 2 * Math.PI; // azimuthal angle
        const theta = Math.acos(2 * Math.random() - 1); // polar angle

        const x = Math.random() * radius * Math.sin(theta) * Math.cos(phi);
        const y = Math.random() * radius * Math.sin(theta) * Math.sin(phi);
        const z = Math.random() * radius * Math.cos(theta);
        data[i + 0] = x * 2;
        data[i + 1] = y * 4 - 2 * y;
        data[i + 2] = -1 * z;
        data[i + 3] = 1;
      }
    }

    function init() {
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      initGPGPU();

      let positions = new Float32Array(SIMULATION_WIDTH ** 2 * 3);
      let references = new Float32Array(SIMULATION_WIDTH ** 2 * 2);
      for (let i = 0; i < SIMULATION_WIDTH ** 2; i++) {
        let x = Math.random();
        let y = Math.random();
        let z = Math.random();
        positions.set([x, y, z], i * 3);

        // Reference column and row number
        let xx = (i % SIMULATION_WIDTH) / SIMULATION_WIDTH;
        let yy = ~~(i / SIMULATION_WIDTH) / SIMULATION_WIDTH;
        references.set([xx, yy], i * 2);
      }

      geometry = new THREE.BufferGeometry();
      geometry.setAttribute(
        'position',
        new THREE.BufferAttribute(positions, 3),
      );
      geometry.setAttribute(
        'reference',
        new THREE.BufferAttribute(references, 2),
      );

      material = new THREE.ShaderMaterial({
        uniforms: {
          ...uniforms,
        },
        vertexShader,
        fragmentShader,
        side: THREE.DoubleSide,
        transparent: true,
      });

      mesh = new THREE.Points(geometry, material);
      mesh.castShadow = true;

      scene.add(mesh);

      var particles = new THREE.Points(
        new THREE.SphereGeometry(5, 12, 8),
        new THREE.PointsMaterial({ size: 2 }),
      );
      particles.position.set(10, 10, 0);
      particles.castShadow = true;
      scene.add(particles);

      var sphere = new THREE.Mesh(
        new THREE.SphereGeometry(5, 12, 8),
        new THREE.MeshStandardMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.7,
        }),
      );
      sphere.castShadow = true;
      sphere.position.set(-10, 10, 0);
      scene.add(sphere);

      createLights();
      createWall();
      handleEvents();
      // postProcessing();
      registerRenderCallback(animationLoop);
      isReady.set(true);
    }

    function postProcessing() {
      heatPass = new ShaderPass({
        uniforms: {
          ...uniforms,
          tDiffuse: { value: null },
        },
        vertexShader: heatPassVertexShader,
        fragmentShader: heatPassFragmentShader,
      });

      heatPass.setSize(window.innerWidth, window.innerHeight);
      composer.addPass(heatPass);
    }

    function createWall() {
      let geometry = new THREE.PlaneGeometry(100, 100, 10, 10);
      let material = new THREE.MeshStandardMaterial({
        metalness: 0,
        roughness: 0,
      });

      const wall = new THREE.Mesh(geometry, material);
      wall.receiveShadow = true;
      wall.position.z = -50;
      wall.position.y = 2;
      scene.add(wall);

      geometry = new THREE.PlaneGeometry(100, 100, 10, 10);
      material = new THREE.MeshStandardMaterial({ metalness: 0, roughness: 0 });

      const ground = new THREE.Mesh(geometry, material);
      ground.receiveShadow = true;
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -10;
      scene.add(ground);
    }

    function createLights() {
      spotLight = new THREE.SpotLight(0xffffff, 0.5);
      spotLight.angle = 3.06;
      spotLight.penumbra = 1;
      spotLight.position.set(50, 500, 500);
      spotLight.castShadow = true;
      spotLight.shadow.mapSize.width = 1024;
      spotLight.shadow.mapSize.height = 1024;
      spotLight.shadow.camera.near = 1;
      spotLight.shadow.camera.far = 1000;

      // spotLight.position.set(0, -5, 8);
      const spotLightHelper = new THREE.SpotLightHelper(spotLight);
      scene.add(spotLightHelper);
      scene.add(spotLight);
    }

    init();
  }

  Scene();
</script>
