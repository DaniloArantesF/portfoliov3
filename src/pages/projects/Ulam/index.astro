---
import SceneLayout from 'src/layouts/SceneLayout.astro';
---

<SceneLayout title={'Ulam Waves'} />

<script>
  import * as THREE from 'three';
  import BaseScene, { BaseSceneState, isReady } from '@lib/sceneController';
  import basicVertexShader from './shaders/vertex.vs.glsl?raw';
  import basicFragmentShader from './shaders/fragment.fs.glsl?raw';
  import { inRange, isPrime } from '@utils/math';

  /* ---------------------------------------------- */
  /*                 Setup & Globals                */
  /* ---------------------------------------------- */
  const canvas = document.getElementById('app_view')! as HTMLCanvasElement;
  const { state, utils, registerRenderCallback } = BaseScene({
    canvas,
    settings: {
      orbitControls: false,
      cameraPosition: [0, 1.5, 0],
      gridHelper: false,
    },
  });
  const { scene, renderer, camera } = state;

  const settings = {
    gridSize: { x: 100, y: 100 }, // [x, y]
    waveAmplitude: 0.3,
    waveFrequency: 5,
  };

  const uniforms = {
    ...state.uniforms,
    waveFrequency: { value: settings.waveFrequency },
    waveAmplitude: { value: settings.waveAmplitude },
  };

  // Return a m x n list of booleans indicating whether a cell is prime
  function UlamSpiral(size: number[]): Array<Array<number>> {
    // let start = Date.now();
    const spiral = new Array(size[1])
      .fill(0)
      .map(() => new Array<number>(size[0]).fill(0));

    let directions = [
      [0, 1],
      [1, 0],
      [0, -1],
      [-1, 0],
    ];
    let direction = 1;

    let x = ~~((size[0] - 1) / 2),
      y = ~~((size[1] - 1) / 2);

    let curPathLength = 1; // number of steps in current path
    let curDistance = 0; // number of steps traveled so far
    let turns = 2; // turn counter to update path length
    let curNumber = 1; // number to be written

    while (inRange(0, size[0], x) && inRange(0, size[1], y)) {
      while (curDistance < curPathLength) {
        // Write current number
        spiral[y][x] = Number(isPrime(curNumber));
        curNumber++;
        curDistance++;

        // Update coords
        (y += directions[direction][1]), (x += directions[direction][0]);
      }

      // Cycle to next direction
      direction = (direction + 1) % 4;

      // Every other turn the current path length goes up by one
      turns--;
      if (turns === 0) {
        curPathLength++;
        turns = 2;
      }

      // Reset distance
      curDistance = 0;
    }

    // const end = Date.now();
    // console.log({ delta: `${(end - start)}` })
    return spiral;
  }

  function setupGUI() {
    const gui = utils.gui;

    gui
      .addInput(settings, 'waveAmplitude', {
        step: 0.001,
        min: 0.05,
        max: 2,
      })
      .on('change', ({ value }) => {
        uniforms.waveAmplitude.value = value;
      });

    gui
      .addInput(settings, 'waveFrequency', {
        step: 0.01,
        min: 0.01,
        max: 50,
      })
      .on('change', ({ value }) => {
        uniforms.waveFrequency.value = value;
      });

    // TODO
    // gui.addInput(settings, 'gridSize');
  }
  setupGUI();

  /* ---------------------------------------------- */
  /*                      Scene                     */
  /* ---------------------------------------------- */
  const geometry = new THREE.PlaneGeometry(
    2,
    2,
    settings.gridSize.x,
    settings.gridSize.y,
  );

  const pointCount = geometry.attributes.position.array.length / 3;
  const spiralSize = Math.ceil(Math.sqrt(pointCount));

  // Calculate number spiral
  const numberSpiral = UlamSpiral([spiralSize, spiralSize]).flat();
  const typed = new Float32Array(numberSpiral);
  const spiralBuffer = new THREE.BufferAttribute(typed, 1);
  geometry.setAttribute('isPrime', spiralBuffer);

  const material = new THREE.ShaderMaterial({
    uniforms,
    vertexShader: basicVertexShader,
    fragmentShader: basicFragmentShader,
    transparent: true,
  });

  const points = new THREE.Points(geometry, material);
  points.rotateX(-Math.PI / 2);
  scene.add(points);

  function animationLoop(state: BaseSceneState) {
    if (!state.orbitControls.enabled) {
      let time = state.time * 0.05;
      camera.position.x = -Math.sin(time) / 4;
      camera.position.z = Math.cos(time) / 4;
      camera.lookAt(scene.position);
    }
  }

  registerRenderCallback(animationLoop);
  isReady.set(true);
</script>
