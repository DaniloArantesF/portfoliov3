---
import SceneLayout from 'src/layouts/SceneLayout.astro';
---

<SceneLayout title={'Ulam Waves'} audio />
<!-- FIX FIREFOX -->
<script>
  import * as THREE from 'three';
  import BaseScene, { BaseSceneState, isReady } from '@lib/sceneController';
  import basicVertexShader from './shaders/vertex.vs.glsl?raw';
  import basicFragmentShader from './shaders/fragment.fs.glsl?raw';
  import { inRange, isPrime } from '@utils/math';
  import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass';
  import globePassVertexShader from './shaders/globePass.vs.glsl?raw';
  import globePassFragmentShader from './shaders/globePass.fs.glsl?raw';
  import { usePlayer } from '@components/Player';

  // TODO: adaptive grid size and params
  // TODO: allow sound processing to be turned off
  /* ---------------------------------------------- */
  /*                 Setup & Globals                */
  /* ---------------------------------------------- */
  let globePass: ShaderPass;
  const canvas = document.getElementById('app_view')! as HTMLCanvasElement;

  const { state, utils, registerRenderCallback, setSceneHook } = BaseScene({
    canvas,
    settings: {
      orbitControls: false,
    },
  });
  const { scene, renderer, camera, composer } = state;

  const settings = {
    cameraPosition: [0, 2, 0],
    gridSize: { x: 100, y: 100 }, // [x, y]
    waveAmplitude: 0.3,
    waveFrequency: 5,
    uActive: true,
    uProgress: 1,
    uScale: 1.15,
    uPower: 11,
    uSize: 0.1,
  };

  const uniforms = {
    ...state.uniforms,
    waveFrequency: { value: settings.waveFrequency },
    waveAmplitude: { value: settings.waveAmplitude },
  };

  /* ---------- Audio ---------- */
  let player = usePlayer.get();
  uniforms.uData = { value: player.buffer };

  // Return a m x n list of booleans indicating whether a cell is prime
  function UlamSpiral(size: number[]): Array<Array<number>> {
    // let start = Date.now();
    const spiral = new Array(size[1])
      .fill(0)
      .map(() => new Array<number>(size[0]).fill(0));

    let directions = [
      [0, 1],
      [1, 0],
      [0, -1],
      [-1, 0],
    ];
    let direction = 1;

    let x = ~~((size[0] - 1) / 2),
      y = ~~((size[1] - 1) / 2);

    let curPathLength = 1; // number of steps in current path
    let curDistance = 0; // number of steps traveled so far
    let turns = 2; // turn counter to update path length
    let curNumber = 1; // number to be written

    while (inRange(0, size[0], x) && inRange(0, size[1], y)) {
      while (curDistance < curPathLength) {
        // Write current number
        spiral[y][x] = Number(isPrime(curNumber));
        curNumber++;
        curDistance++;

        // Update coords
        (y += directions[direction][1]), (x += directions[direction][0]);
      }

      // Cycle to next direction
      direction = (direction + 1) % 4;

      // Every other turn the current path length goes up by one
      turns--;
      if (turns === 0) {
        curPathLength++;
        turns = 2;
      }

      // Reset distance
      curDistance = 0;
    }

    // const end = Date.now();
    // console.log({ delta: `${(end - start)}` })
    return spiral;
  }

  function setupGUI() {
    const gui = utils.gui;

    gui
      .addInput(settings, 'waveAmplitude', {
        step: 0.001,
        min: 0.05,
        max: 2,
      })
      .on('change', ({ value }) => {
        uniforms.waveAmplitude.value = value;
      });

    gui
      .addInput(settings, 'waveFrequency', {
        step: 0.01,
        min: 0.01,
        max: 50,
      })
      .on('change', ({ value }) => {
        uniforms.waveFrequency.value = value;
      });

    gui
      .addInput(settings, 'uScale', { min: -5, max: 10, step: 0.01 })
      .on('change', () => (globePass.uniforms.uScale.value = settings.uScale));
    gui
      .addInput(settings, 'uPower', { min: -5, max: 50, step: 0.1 })
      .on('change', () => (globePass.uniforms.uPower.value = settings.uPower));
    gui
      .addInput(settings, 'uSize', { min: -2, max: 5, step: 0.01 })
      .on('change', () => (globePass.uniforms.uSize.value = settings.uSize));
    gui
      .addInput(settings, 'uProgress', { min: 0, max: 1, step: 0.01 })
      .on(
        'change',
        () => (globePass.uniforms.uProgress.value = settings.uProgress),
      );
    gui
      .addInput(settings, 'uActive')
      .on(
        'change',
        () => (globePass.uniforms.uActive.value = settings.uActive),
      );
  }

  let focusPoint = new THREE.Vector3(0, 1.5, 0).add(scene.position);
  function animationLoop(state: BaseSceneState) {
    if (!state.orbitControls.enabled) {
      let time = state.time * 0.05;
      camera.position.x = -Math.sin(time) / 2;
      // camera.position.y = 1 + Math.cos(time) / 4;
      camera.position.z = Math.cos(time) / 2;
      camera.lookAt(focusPoint);
    }

    if (player) {
      let analyser = player.analyser;
      analyser?.getByteFrequencyData(player.buffer);
      uniforms.uData.value = player.buffer;
    }
  }

  function calculateZ(
    targetZ: number,
    targetHeight1 = window.innerHeight / 8,
    targetHeight2 = window.innerHeight / 2,
  ) {
    let vFOV = (camera.fov * Math.PI) / 180;

    // calculate height of viewport as seen from camera position
    let vHeightPartial = 2 * Math.tan(vFOV / 2);

    var p1 = targetHeight1 * window.innerHeight;
    var p2 = targetZ * vHeightPartial;
    var p3 = targetHeight2 * vHeightPartial;
    var p4 = targetHeight2 * p2;
    var p5 = p1 + p4;
    var z = p5 / p3;
    return z;
  }

  function handleEvents() {
    // Handle resize
    setSceneHook('onResize', () => {
      globePass.uniforms.uResolution.value = new THREE.Vector2(
        window.innerWidth,
        window.innerHeight,
      );
      utils.updateSetting('cameraPosition', settings.cameraPosition);
      utils.resetCamera();
    });
  }

  function postProcessing() {
    globePass = new ShaderPass({
      uniforms: {
        ...uniforms,
        tDiffuse: { value: null },
        uBackgroundColor: { value: new THREE.Color(0x090c1b) },
        uProgress: { value: settings.uProgress },
        uScale: { value: settings.uScale },
        uPower: { value: settings.uPower },
        uSize: { value: settings.uSize },
        uActive: { value: settings.uActive },
      },
      vertexShader: globePassVertexShader,
      fragmentShader: globePassFragmentShader,
    });

    composer.addPass(globePass);
  }

  /* ---------------------------------------------- */
  /*                      Scene                     */
  /* ---------------------------------------------- */
  const geometry = new THREE.PlaneGeometry(
    10,
    10,
    settings.gridSize.x,
    settings.gridSize.y,
  );

  const pointCount = geometry.attributes.position.array.length / 3;
  const spiralSize = Math.ceil(Math.sqrt(pointCount));

  // Calculate number spiral
  const numberSpiral = UlamSpiral([spiralSize, spiralSize]).flat();
  const typed = new Float32Array(numberSpiral);
  const spiralBuffer = new THREE.BufferAttribute(typed, 1);
  geometry.setAttribute('isPrime', spiralBuffer);

  const material = new THREE.ShaderMaterial({
    uniforms,
    vertexShader: basicVertexShader,
    fragmentShader: basicFragmentShader,
    transparent: true,
  });

  const points = new THREE.Points(geometry, material);
  points.rotateX(-Math.PI / 2);
  scene.add(points);

  // Set default camera position
  utils.updateSetting('cameraPosition', settings.cameraPosition);
  utils.resetCamera();

  postProcessing();
  setupGUI();
  handleEvents();
  registerRenderCallback(animationLoop);
  isReady.set(true);
</script>
