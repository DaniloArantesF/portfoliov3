---
import StealthLayout from '../../../layouts/StealthLayout.astro';
---

<StealthLayout title="SpaceJams">
  <main id="container">
    <canvas id="app_view"></canvas>
    <div id="gui_container"></div>
    <div id="player_container">
      <div class="controls">
        <input type="file" id="fileIn" />
        <button id="load-default">Load Song</button>
      </div>
    </div>
  </main>
</StealthLayout>

<script>
  import * as THREE from 'three';
  import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
  import vertexShader from './shaders/vertex.vs.glsl?raw';
  import fragmentShader from './shaders/fragment.fs.glsl?raw';
  import bodyVertexShader from './shaders/body.vs.glsl?raw';
  import bodyFragmentShader from './shaders/body.fs.glsl?raw';
  import skyVertexShader from './shaders/sky.vs.glsl?raw';
  import skyFragmentShader from './shaders/sky.fs.glsl?raw';
  import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
  import { SSRPass } from 'three/examples/jsm/postprocessing/SSRPass';
  import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
  import { ReflectorForSSRPass } from 'three/examples/jsm/objects/ReflectorForSSRPass';
  // import { FilmPass } from 'three/examples/jsm/postprocessing/FilmPass.js';
  // import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass';
  // import { RGBShiftShader } from 'three/examples/jsm/shaders/RGBShiftShader';
  import Stats from 'three/examples/jsm/libs/stats.module';
  import * as dat from 'dat.gui';

  /* ---------------------------------------------- */
  /*                   Constants                    */
  /* ---------------------------------------------- */
  const ORBIT_CONTROLS = false;

  const App = () => {
    /* ---------------------------------------------- */
    /*                    Graphics                    */
    /* ---------------------------------------------- */
    const canvas = document.querySelector('#app_view') as HTMLCanvasElement;
    let camera: THREE.PerspectiveCamera,
      scene: THREE.Scene,
      renderer: THREE.WebGLRenderer,
      composer: EffectComposer,
      renderScene: RenderPass;
    let bloomPass: UnrealBloomPass,
      ssrPass: SSRPass,
      groundReflector: ReflectorForSSRPass;
    const selects: any[] = [];

    /* ---------------------------------------------- */
    /*                      Audio                     */
    /* ---------------------------------------------- */
    let audioContext: AudioContext,
      analyser: AnalyserNode,
      source: MediaElementAudioSourceNode;
    let dataArray = new Uint8Array();
    const audio = new Audio();
    document.getElementById('player_container')!.appendChild(audio);
    audio.controls = true;
    audio.volume = 0.4;

    /* ---------------------------------------------- */
    /*                      Scene                     */
    /* ---------------------------------------------- */
    let loader: GLTFLoader;
    let speaker: THREE.Group, background: THREE.Object3D;

    /* ---------------------------------------------- */
    /*                    Settings                    */
    /* ---------------------------------------------- */
    let gui: dat.GUI;
    const settings = {
      texScale: 150,
      exposure: 1,
      enableSSR: true,
      orbitControls: false,
      autoRotate: false,
      groundReflector: true,
      bloomStrength: 0.46,
      bloomThreshold: 0.6,
      bloomRadius: 0.4,
    };
    let controls: OrbitControls, clock: THREE.Clock, time: number;
    let cameraPole: THREE.Object3D, gridHelper: THREE.GridHelper;
    let stats: Stats;
    const fov = 75;
    const aspect = window.innerWidth / window.innerHeight;
    const near = 0.1;
    const far = 10000;
    const uniforms = {
      uResolution: {
        value: new THREE.Vector2(window.innerWidth, window.innerHeight),
        type: 'v2',
      },
      uTime: {
        type: 'f',
        value: 0.0,
      },
      uMouse: { value: { x: 0, y: 0 } },
      uTest: { value: 1 },
      uData: { type: `float[128]`, value: dataArray },
      uScale: { type: 'f', value: settings.texScale },
    };

    async function init() {
      scene = new THREE.Scene();
      renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: true,
      });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);

      composer = new EffectComposer(renderer);
      clock = new THREE.Clock();

      loadModels();
    }

    function initAudio() {
      audioContext = new window.AudioContext();
      source = audioContext.createMediaElementSource(audio);

      // exposes audio time and frequency data
      analyser = audioContext.createAnalyser();

      // pipe audio source through analyzer
      source.connect(analyser);

      // output audio to default speaker device
      analyser.connect(audioContext.destination);
      analyser.fftSize = 256; // sampling rate

      // array holding 8-bit integers representing frequencies
      // analyser.frequencyBinCount is equal to fftSize / 2
      dataArray = new Uint8Array(analyser.frequencyBinCount);
    }

    function loadModels() {
      loader = new GLTFLoader();
      loader.load('/assets/models/speaker.glb', (model) => {
        background = model.scene.children[0];
        speaker = new THREE.Group();
        speaker.add(...model.scene.children.slice(1));
        selects.push(...model.scene.children.slice(1));
        let body = speaker.children[2] as THREE.Mesh;
        body.material = new THREE.ShaderMaterial({
          uniforms,
          vertexShader: bodyVertexShader,
          fragmentShader: bodyFragmentShader,
        });

        body.rotateY(Math.PI / 2);
        background.scale.set(5, 5, 15);
        background.rotateY(-Math.PI / 2);
        speaker.scale.set(5, 5, 5);
        speaker.castShadow = true;
        speaker.receiveShadow = true;
        scene.add(speaker);

        initScene();
        postProcessing();
        initGUI();

        render();
      });
    }

    function initScene() {
      /* --------- Camera --------- */
      camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      camera.position.set(0, 50, 25);

      cameraPole = new THREE.Object3D();
      scene.add(cameraPole);
      cameraPole.add(camera);

      /* ---------- Lights ---------- */
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
      scene.add(ambientLight);

      const rimLight = new THREE.PointLight(0xffffff, 0.5);
      rimLight.position.set(150, 100, -20);
      scene.add(rimLight);
      const rimLight2 = new THREE.PointLight(0xffffff, 0.5);
      rimLight2.position.set(-150, 100, -20);
      scene.add(rimLight2);

      const spotLight = new THREE.SpotLight(0xffffff, 0.5);
      spotLight.position.set(10, 150, 200);
      spotLight.castShadow = true;
      spotLight.shadow.mapSize.width = 1024;
      spotLight.shadow.mapSize.height = 1024;
      scene.add(spotLight);

      const rimLightHelper = new THREE.PointLightHelper(rimLight, 0.5);
      const rimLightHelper2 = new THREE.PointLightHelper(rimLight2, 0.5);
      scene.add(rimLightHelper);
      scene.add(rimLightHelper2);
      const spotLightHelper = new THREE.PointLightHelper(spotLight, 0.5);
      scene.add(spotLightHelper);

      // // Lights
      // const hemiLight = new THREE.HemisphereLight(0x443333, 0x111122);
      // scene.add(hemiLight);

      // const spotLight = new THREE.SpotLight();
      // spotLight.angle = Math.PI / 16;
      // spotLight.penumbra = 0.5;
      // // spotLight.castShadow = true;
      // spotLight.position.set(-1, 1, 1);
      // scene.add(spotLight);

      /* ---------- Utils ---------- */
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enabled = false;
      controls.autoRotateSpeed = 0.5;
      gridHelper = new THREE.GridHelper(200, 10);
      // scene.add(gridHelper);

      stats = Stats();
      stats.dom.style.display = 'inline-block';
      document.querySelector('#gui_container')!.appendChild(stats.dom);
      /* ---------- Geometry ---------- */

      const skyGeometry = new THREE.PlaneGeometry(1000, 1000);
      const skyMaterial = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: skyVertexShader,
        fragmentShader: skyFragmentShader,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        side: THREE.DoubleSide,
      });

      const sky = new THREE.Mesh(skyGeometry, skyMaterial);
      sky.position.set(0, 0, -75);
      scene.add(sky);
      selects.push(sky);

      const material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader,
        fragmentShader,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
      });

      const fibonacciSphereV3 = (samples: number, scale: number) => {
        const gAng = 2.399963229728; // [golden angle: pi * (3 - sqrt(5))]
        const points = [];
        for (let i = 0; i < samples; i++) {
          const y = 1.0 - (i / (samples - 1)) * 2.0;
          const radius = Math.sqrt(1.0 - y * y);
          const theta = gAng * i;
          const x = Math.cos(theta) * radius;
          const z = Math.sin(theta) * radius;
          const v3 = new THREE.Vector3(x * scale, y * scale, z * scale);
          points.push(v3);
        }
        return points;
      };

      const mesh = new THREE.Mesh(
        new THREE.SphereGeometry(64, 100, 100),
        material,
      );
      const points = new THREE.Points(
        new THREE.BufferGeometry().setFromPoints(fibonacciSphereV3(30000, 64)),
        material,
      );

      // speaker.add(mesh);
      speaker.rotateY(Math.PI / 2);
      const plate = speaker.children[4];
      // mesh.position.set(
      //   plate.position.x + 0.3,
      //   plate.position.y + 5.68,
      //   plate.position.z + 11,
      // );
      //mesh.rotation.set(plate.rotation.x, plate.rotation.y - Math.PI / 2, plate.rotation.z);

      points.position.set(14, 7, -0.3);
      points.rotateZ(-Math.PI / 2);

      points.scale.set(
        plate.scale.x / 13.5,
        plate.scale.y / 20,
        plate.scale.z / 13.5,
      );

      mesh.position.set(14, 7, -0.3);
      mesh.rotateZ(-Math.PI / 2);

      mesh.scale.set(
        plate.scale.x / 13.5,
        plate.scale.y / 20,
        plate.scale.z / 13.5,
      );

      scene.add(points);
      scene.add(mesh);
      selects.push(mesh);

      // Rock
      const rockColorMap = new THREE.TextureLoader().load(
        '/assets/textures/ground_color_1k.jpg',
      );
      const rockDisplacementMap = new THREE.TextureLoader().load(
        '/assets/textures/ground_height_1k.png',
      );
      const rockRoughnessMap = new THREE.TextureLoader().load(
        '/assets/textures/ground_roughness_1k.jpg',
      );
      const rockAoMap = new THREE.TextureLoader().load(
        '/assets/textures/ground_ao_1k.jpg',
      );
      const rockNormalMap = new THREE.TextureLoader().load(
        '/assets/textures/ground_normal_opengl_1k.png',
      );

      [
        rockColorMap,
        rockDisplacementMap,
        rockRoughnessMap,
        rockAoMap,
        rockNormalMap,
      ].forEach((t) => {
        t.wrapS = THREE.RepeatWrapping;
        t.wrapT = THREE.RepeatWrapping;
        t.repeat.set(1.5, 1.5);
        t.encoding = THREE.LinearEncoding;
      });

      const rockGeometry = new THREE.ConeGeometry(50, 50, 100);
      const rockMaterial = new THREE.MeshStandardMaterial({
        map: rockColorMap,
        displacementBias: -0.5,
        displacementMap: rockDisplacementMap,
        normalMap: rockNormalMap,
        roughnessMap: rockRoughnessMap,
        aoMap: rockAoMap,
        side: THREE.DoubleSide,
      });

      const rockMesh = new THREE.Mesh(rockGeometry, rockMaterial);
      scene.add(rockMesh);
      rockMesh.rotation.x -= Math.PI;
      // add extra .25 for ground reflector
      rockMesh.position.y -= 25.25;

      // Add ground reflections
      let geometry = new THREE.PlaneGeometry(100, 100);
      groundReflector = new ReflectorForSSRPass(geometry, {
        clipBias: 0.0003,
        textureWidth: window.innerWidth,
        textureHeight: window.innerHeight,
        color: 0x888888,
        useDepthTexture: true,
      });

      groundReflector.material.depthWrite = false;
      groundReflector.rotation.x = -Math.PI / 2;
      groundReflector.position.y += 0.5;
      groundReflector.visible = false;
      scene.add(groundReflector);

      /* ---------- Events ---------- */
      canvas.addEventListener('mousemove', (event) => {
        uniforms.uMouse.value.x =
          (event.clientX - window.innerWidth / 2) * 0.05;
        uniforms.uMouse.value.y =
          (event.clientY - window.innerHeight / 2) * 0.01;
      });

      window.addEventListener('resize', () => {
        uniforms.uResolution.value = new THREE.Vector2(
          window.innerWidth,
          window.innerHeight,
        );
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
        groundReflector
          .getRenderTarget()
          .setSize(window.innerWidth, window.innerHeight);
        // groundReflector.resolution.set( window.innerWidth, window.innerHeight );
        // camera.position.set(0, 40, 40);
      });

      // Handle file upload
      const fileInput = document.getElementById('fileIn');
      fileInput?.addEventListener('change', async function (event) {
        const el = event.target as HTMLInputElement;
        if (el && el.files) {
          const file = el.files[0];
          audio.src = URL.createObjectURL(file);
          audio.load();
        }
      });

      // Setup audio context when file is loaded
      audio.onloadeddata = () => {
        initAudio();
      };

      audio.addEventListener('play', () => {
        // controls.autoRotate = true;
        audioContext.resume();
        audio.play();
        console.log(dataArray.length);
      });

      audio.addEventListener('pause', () => {
        controls.autoRotate = false;
      });

      const loadDefaultButton = document.getElementById('load-default');
      loadDefaultButton?.addEventListener('click', () => {
        loadDefaultSong();
      });
    }

    function loadDefaultSong() {
      audio.src = '/assets/songs/song1.mp3';
      audio.load();
    }

    function initGUI() {
      gui = new dat.GUI({ autoPlace: false });
      gui.width = 300;
      gui.domElement.id = 'gui';
      gui.domElement.style.display = 'inline-block';

      document.getElementById('gui_container')!.append(gui.domElement);

      gui.add(settings, 'groundReflector').onChange(() => {
        if (settings.groundReflector) {
          ssrPass.groundReflector = groundReflector;
          ssrPass.selects = selects;
        } else {
          ssrPass.groundReflector = null;
          ssrPass.selects = null;
        }
      });

      gui.add(settings, 'bloomThreshold', 0.0, 1.0).onChange((value) => {
        bloomPass.threshold = Number(value);
      });

      gui.add(settings, 'bloomStrength', 0.0, 3.0).onChange((value) => {
        bloomPass.strength = Number(value);
      });

      gui
        .add(settings, 'bloomRadius', 0.0, 1.0)
        .step(0.01)
        .onChange((value) => {
          bloomPass.radius = Number(value);
        });

      gui.add(settings, 'orbitControls').onChange((value) => {
        controls.enabled = value;
        if (!value) {
          camera.position.set(0, 50, 25);
        }
      });

      gui.add(settings, 'autoRotate').onChange((value) => {
        if (value) {
          controls.enabled = true;
          settings.orbitControls = true;
          gui.updateDisplay();
        }
        controls.autoRotate = value;
      });

      const folder = gui.addFolder('SSR');
      // folder.add(ssrPass, 'fresnel').onChange(() => {
      //   groundReflector.fresnel = ssrPass.fresnel;
      // });

      folder.add(ssrPass, 'thickness').min(0).max(0.1).step(0.0001);
      // ssrPass.infiniteThick = false;
      // folder.add(ssrPass, 'infiniteThick');
      // folder.add(ssrPass, 'distanceAttenuation').onChange(() => {
      //   groundReflector.distanceAttenuation = ssrPass.distanceAttenuation;
      // });

      groundReflector.maxDistance = ssrPass.maxDistance;
      folder
        .add(ssrPass, 'maxDistance')
        .min(0)
        .max(50)
        .step(0.001)
        .onChange(() => {
          groundReflector.maxDistance = ssrPass.maxDistance;
        });

      folder.add(ssrPass, 'bouncing');

      folder
        .add(ssrPass, 'output', {
          Default: SSRPass.OUTPUT.Default,
          'SSR Only': SSRPass.OUTPUT.SSR,
          Beauty: SSRPass.OUTPUT.Beauty,
          Depth: SSRPass.OUTPUT.Depth,
          Normal: SSRPass.OUTPUT.Normal,
          Metalness: SSRPass.OUTPUT.Metalness,
        })
        .onChange(function (value) {
          ssrPass.output = parseInt(value);
        });

      groundReflector.opacity = ssrPass.opacity;
      folder
        .add(ssrPass, 'opacity')
        .min(0)
        .max(1)
        .onChange(() => {
          groundReflector.opacity = ssrPass.opacity;
        });
      folder.add(ssrPass, 'blur');
      gui.close();
    }

    function render() {
      requestAnimationFrame(render);
      time = clock.getElapsedTime();
      if (analyser) {
        // each item represents decibel value for specific frequency
        // freqs go from 0 to 1/2 of the sample rate
        analyser.getByteFrequencyData(dataArray);
      }

      // Update uniforms
      uniforms.uData.value = dataArray;
      uniforms.uTime.value = time;

      if (settings.orbitControls) {
        controls.update();
      } else {
        camera.position.x +=
          (uniforms.uMouse.value.x - camera.position.x) * 0.03;
        camera.position.y +=
          (-uniforms.uMouse.value.y - camera.position.y) * 0.05 + 1;
        camera.lookAt(scene.position);
      }
      stats.begin();
      composer.render();
      stats.end();
    }

    function postProcessing() {
      renderScene = new RenderPass(scene, camera);
      bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        settings.bloomStrength,
        settings.bloomRadius,
        settings.bloomThreshold,
      );

      ssrPass = new SSRPass({
        renderer,
        scene,
        camera,
        width: window.innerWidth,
        height: window.innerHeight,
        groundReflector: settings.groundReflector ? groundReflector : null,
        selects: settings.groundReflector ? selects : null,
      });
      ssrPass.thickness = 0.018;
      ssrPass.maxDistance = 2.3;
      ssrPass.output = SSRPass.OUTPUT.Beauty;
      ssrPass.opacity = 1;

      composer.addPass(renderScene);
      composer.addPass(ssrPass);
      composer.addPass(bloomPass);

      // composer.addPass( new ShaderPass( RGBShiftShader ) );
    }

    init();
  };

  App();
</script>

<style is:global>
  html {
    height: 100vh;
    overflow: hidden;
  }

  /* audio {
    position: absolute;
    right: 4rem;
    bottom: 2rem;
  } */

  audio {
    width: 100%;
    max-width: 300px;
    margin: 0 auto;
  }
</style>

<style>
  body {
    width: 100%;
    height: 100vh;
    background: var(--color-background);
    overflow: hidden;
    overscroll-behavior: none;
    margin: 0;
    padding: 0;
  }

  #app_view {
    display: block;
    width: 100%;
    height: 100%;
  }

  #container {
    position: relative;
    width: 100%;
    height: 100%;
  }

  #gui_container {
    position: absolute;
    top: var(--header-height);
    left: 2rem;
  }

  #gui {
    position: absolute;
    top: 0;
    left: 0;
  }

  #player_container {
    display: inline-flex;
    flex-direction: column;
    position: absolute;
    bottom: 0;
    width: 100%;
    max-width: 400px;
    margin-bottom: 1rem;
    row-gap: 1rem;
  }

  .controls {
    display: flex;
    flex-direction: column;
    row-gap: 2rem;
    transform: scale(0.9);
  }
</style>
