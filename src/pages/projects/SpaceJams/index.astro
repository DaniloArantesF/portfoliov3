---
import { PlayerController } from '../../../components/PlayerController';
import StealthLayout from '../../../layouts/StealthLayout.astro';
---

<StealthLayout title="SpaceJams">
  <main id="container">
    <canvas id="app_view"></canvas>
    <div id="gui_container"></div>
    <div id="player_container">
      <audio></audio>
      <div class="controls">
        <PlayerController client:only="react" />
      </div>
    </div>
  </main>
</StealthLayout>

<script>
  import * as THREE from 'three';
  import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
  import vertexShader from './shaders/vertex.vs.glsl?raw';
  import fragmentShader from './shaders/fragment.fs.glsl?raw';
  import bodyVertexShader from './shaders/body.vs.glsl?raw';
  import bodyFragmentShader from './shaders/body.fs.glsl?raw';
  import skyVertexShader from './shaders/sky.vs.glsl?raw';
  import skyFragmentShader from './shaders/sky.fs.glsl?raw';
  import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
  import { SSRPass } from 'three/examples/jsm/postprocessing/SSRPass';
  import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
  import { ReflectorForSSRPass } from 'three/examples/jsm/objects/ReflectorForSSRPass';
  // import { FilmPass } from 'three/examples/jsm/postprocessing/FilmPass.js';
  // import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass';
  // import { RGBShiftShader } from 'three/examples/jsm/shaders/RGBShiftShader';
  import Stats from 'three/examples/jsm/libs/stats.module';
  import * as dat from 'dat.gui';
  import Player from '../../../components/Player';

  /* ---------------------------------------------- */
  /*                   Constants                    */
  /* ---------------------------------------------- */

  const App = () => {
    /* ---------------------------------------------- */
    /*                    Graphics                    */
    /* ---------------------------------------------- */
    const canvas = document.querySelector('#app_view') as HTMLCanvasElement;
    let camera: THREE.PerspectiveCamera,
      scene: THREE.Scene,
      renderer: THREE.WebGLRenderer,
      composer: EffectComposer,
      renderScene: RenderPass;
    let bloomPass: UnrealBloomPass,
      ssrPass: SSRPass,
      groundReflector: ReflectorForSSRPass;
    const selects: any[] = [];

    /* ---------------------------------------------- */
    /*                      Audio                     */
    /* ---------------------------------------------- */
    let player = Player.getInstance();

    /* ---------------------------------------------- */
    /*                      Scene                     */
    /* ---------------------------------------------- */
    let loader: GLTFLoader;
    let speaker: THREE.Group, background: THREE.Object3D;

    /* ---------------------------------------------- */
    /*                    Settings                    */
    /* ---------------------------------------------- */
    let gui: dat.GUI;

    const settings = {
      texScale: 123,
      exposure: 1,
      enableSSR: true,
      orbitControls: /Android|webOS|iPhone|iPad/i.test(navigator.userAgent),
      autoRotate: false,
      groundReflector: true,
      bloomStrength: 0.55,
      bloomThreshold: 0.3,
      bloomRadius: 0.6,
    };
    let controls: OrbitControls, clock: THREE.Clock, time: number;
    let cameraPole: THREE.Object3D, gridHelper: THREE.GridHelper;
    let stats: Stats;
    const fov = 75;
    const aspect = window.innerWidth / window.innerHeight;
    const near = 0.1;
    const far = 10000;
    const uniforms = {
      uResolution: {
        value: new THREE.Vector2(window.innerWidth, window.innerHeight),
        type: 'v2',
      },
      uTime: {
        type: 'f',
        value: 0.0,
      },
      uMouse: { value: { x: 0, y: 0 } },
      uTest: { value: 1 },
      uData: { type: `float[128]`, value: player.buffer },
      uScale: { type: 'f', value: settings.texScale },
    };

    async function init() {
      scene = new THREE.Scene();
      renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: true,
      });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);

      composer = new EffectComposer(renderer);
      clock = new THREE.Clock();

      loadModels();
    }

    function loadModels() {
      loader = new GLTFLoader();
      loader.load('/assets/models/speaker.glb', (model) => {
        background = model.scene.children[0];
        speaker = new THREE.Group();
        speaker.add(...model.scene.children.slice(1));
        selects.push(...model.scene.children.slice(1));
        // speaker.children[0].visible = false;
        let body = speaker.children[2] as THREE.Mesh;
        body.material = new THREE.ShaderMaterial({
          uniforms,
          vertexShader: bodyVertexShader,
          fragmentShader: bodyFragmentShader,
        });

        body.rotateY(Math.PI / 2);
        background.scale.set(5, 5, 15);
        background.rotateY(-Math.PI / 2);
        speaker.scale.set(5, 5, 5);
        speaker.castShadow = true;
        speaker.receiveShadow = true;
        scene.add(speaker);

        initScene();
        postProcessing();
        initGUI();
        render();
      });
    }

    function initScene() {
      /* --------- Camera --------- */
      camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      camera.position.set(0, 2, 15);
      // camera.position.set(0, 0, 1000);

      cameraPole = new THREE.Object3D();
      scene.add(cameraPole);
      cameraPole.add(camera);

      /* ---------- Lights ---------- */
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
      scene.add(ambientLight);

      const spotLight = new THREE.SpotLight(0xffffff, 0.5);
      spotLight.angle = Math.PI / 16;
      spotLight.penumbra = 1;

      spotLight.castShadow = true;
      spotLight.position.set(-75, 150, 75);
      scene.add(spotLight);

      const spotLight2 = new THREE.SpotLight(0xaaaaaa, 0.8);
      spotLight2.position.set(10, 100, 200);
      spotLight2.castShadow = true;
      spotLight2.shadow.mapSize.width = 1024;
      spotLight2.shadow.mapSize.height = 1024;
      scene.add(spotLight2);

      const spotLightHelper = new THREE.PointLightHelper(spotLight, 0.5);
      const spotLightHelper2 = new THREE.PointLightHelper(spotLight, 0.5);
      scene.add(spotLightHelper);
      scene.add(spotLightHelper2);

      /* ---------- Utils ---------- */
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enabled = settings.orbitControls;
      controls.autoRotateSpeed = 0.5;
      gridHelper = new THREE.GridHelper(200, 10);
      // scene.add(gridHelper);

      stats = Stats();
      stats.dom.style.display = 'inline-block';
      document.querySelector('#gui_container')!.appendChild(stats.dom);

      /* ---------- Geometry ---------- */
      const skyGeometry = new THREE.SphereGeometry(5000, 300);
      const skyMaterial = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: skyVertexShader,
        fragmentShader: skyFragmentShader,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        side: THREE.DoubleSide,
      });

      const sky = new THREE.Mesh(skyGeometry, skyMaterial);
      sky.position.set(0, 0, -75);
      sky.rotation.y += Math.PI / 2;
      scene.add(sky);
      selects.push(sky);

      const material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader,
        fragmentShader,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
      });

      const fibonacciSphereV3 = (samples: number, scale: number) => {
        const gAng = 2.399963229728; // [golden angle: pi * (3 - sqrt(5))]
        const points = [];
        for (let i = 0; i < samples; i++) {
          const y = 1.0 - (i / (samples - 1)) * 2.0;
          const radius = Math.sqrt(1.0 - y * y);
          const theta = gAng * i;
          const x = Math.cos(theta) * radius;
          const z = Math.sin(theta) * radius;
          const v3 = new THREE.Vector3(x * scale, y * scale, z * scale);
          points.push(v3);
        }
        return points;
      };

      const mesh = new THREE.Mesh(
        new THREE.SphereGeometry(64, 100, 100),
        material,
      );
      const points = new THREE.Points(
        new THREE.BufferGeometry().setFromPoints(fibonacciSphereV3(30000, 64)),
        material,
      );

      // speaker.add(mesh);
      speaker.rotateY(Math.PI / 2);
      const plate = speaker.children[4];

      points.position.set(7, 3.5, -0.15);
      points.rotateZ(-Math.PI / 2);

      points.scale.set(
        plate.scale.x / 13.5,
        plate.scale.y / 20,
        plate.scale.z / 13.5,
      );

      mesh.position.set(7, 3.5, -0.15);
      mesh.rotateZ(-Math.PI / 2);

      mesh.scale.set(
        plate.scale.x / 13.5,
        plate.scale.y / 20,
        plate.scale.z / 13.5,
      );

      speaker.scale.multiply(new THREE.Vector3(0.5, 0.5, 0.5));
      mesh.scale.multiply(new THREE.Vector3(0.5, 0.5, 0.5));
      points.scale.multiply(new THREE.Vector3(0.5, 0.5, 0.5));

      scene.add(points);
      scene.add(mesh);
      selects.push(mesh);

      // Rock
      const rockColorMap = new THREE.TextureLoader().load(
        '/assets/textures/ground_color_1k.jpg',
      );
      const rockDisplacementMap = new THREE.TextureLoader().load(
        '/assets/textures/ground_height_1k.png',
      );
      const rockRoughnessMap = new THREE.TextureLoader().load(
        '/assets/textures/ground_roughness_1k.jpg',
      );
      const rockAoMap = new THREE.TextureLoader().load(
        '/assets/textures/ground_ao_1k.jpg',
      );
      const rockNormalMap = new THREE.TextureLoader().load(
        '/assets/textures/ground_normal_opengl_1k.png',
      );

      [
        rockColorMap,
        rockDisplacementMap,
        rockRoughnessMap,
        rockAoMap,
        rockNormalMap,
      ].forEach((t) => {
        t.wrapS = THREE.RepeatWrapping;
        t.wrapT = THREE.RepeatWrapping;
        t.repeat.set(3, 3);
        t.encoding = THREE.LinearEncoding;
      });

      const rockGeometry = new THREE.ConeGeometry(50, 50, 100);
      const rockMaterial = new THREE.MeshStandardMaterial({
        map: rockColorMap,
        displacementBias: -0.5,
        displacementMap: rockDisplacementMap,
        normalMap: rockNormalMap,
        roughnessMap: rockRoughnessMap,
        aoMap: rockAoMap,
        side: THREE.DoubleSide,
      });

      const rockMesh = new THREE.Mesh(rockGeometry, rockMaterial);
      scene.add(rockMesh);
      rockMesh.rotation.x -= Math.PI;
      // add extra .25 for ground reflector
      rockMesh.position.y -= 25.05;

      // Add ground reflections
      let geometry = new THREE.PlaneGeometry(50, 100);
      groundReflector = new ReflectorForSSRPass(geometry, {
        clipBias: 0.0003,
        textureWidth: window.innerWidth,
        textureHeight: window.innerHeight,
        color: 0x888888,
        useDepthTexture: true,
      });

      groundReflector.material.depthWrite = false;
      groundReflector.rotation.x = -Math.PI / 2;
      groundReflector.position.y += 0.5;
      groundReflector.visible = false;
      scene.add(groundReflector);

      /* ---------- Events ---------- */
      canvas.addEventListener('mousemove', (event) => {
        uniforms.uMouse.value.x =
          (event.clientX - window.innerWidth / 2) * 0.02;
        uniforms.uMouse.value.y =
          (event.clientY - window.innerHeight / 2) * 0.01;
      });

      // TODO: debounce resize handler
      window.addEventListener('resize', () => {
        uniforms.uResolution.value = new THREE.Vector2(
          window.innerWidth,
          window.innerHeight,
        );
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
        groundReflector
          .getRenderTarget()
          .setSize(window.innerWidth, window.innerHeight);
        // groundReflector.resolution.set( window.innerWidth, window.innerHeight );
        // camera.position.set(0, 40, 40);
      });
    }

    function initGUI() {
      gui = new dat.GUI({ autoPlace: false });
      gui.width = 300;
      gui.domElement.id = 'gui';
      gui.domElement.style.display = 'inline-block';

      document.getElementById('gui_container')!.append(gui.domElement);

      gui.add(settings, 'groundReflector').onChange(() => {
        if (settings.groundReflector) {
          ssrPass.groundReflector = groundReflector;
          ssrPass.selects = selects;
        } else {
          ssrPass.groundReflector = null;
          ssrPass.selects = null;
        }
      });

      gui.add(settings, 'bloomThreshold', 0.0, 1.0).onChange((value) => {
        bloomPass.threshold = Number(value);
      });

      gui.add(settings, 'bloomStrength', 0.0, 3.0).onChange((value) => {
        bloomPass.strength = Number(value);
      });

      gui
        .add(settings, 'bloomRadius', 0.0, 1.0)
        .step(0.01)
        .onChange((value) => {
          bloomPass.radius = Number(value);
        });

      gui.add(settings, 'orbitControls').onChange((value) => {
        controls.enabled = value;
        if (!value) {
          camera.position.set(0, 50, 25);
        }
      });

      gui.add(settings, 'autoRotate').onChange((value) => {
        if (value) {
          controls.enabled = true;
          settings.orbitControls = true;
          gui.updateDisplay();
        }
        controls.autoRotate = value;
      });

      const folder = gui.addFolder('SSR');
      // folder.add(ssrPass, 'fresnel').onChange(() => {
      //   groundReflector.fresnel = ssrPass.fresnel;
      // });

      folder.add(ssrPass, 'thickness').min(0).max(0.1).step(0.0001);
      // ssrPass.infiniteThick = false;
      // folder.add(ssrPass, 'infiniteThick');
      // folder.add(ssrPass, 'distanceAttenuation').onChange(() => {
      //   groundReflector.distanceAttenuation = ssrPass.distanceAttenuation;
      // });

      groundReflector.maxDistance = ssrPass.maxDistance;
      folder
        .add(ssrPass, 'maxDistance')
        .min(0)
        .max(50)
        .step(0.001)
        .onChange(() => {
          groundReflector.maxDistance = ssrPass.maxDistance;
        });

      folder.add(ssrPass, 'bouncing');

      folder
        .add(ssrPass, 'output', {
          Default: SSRPass.OUTPUT.Default,
          'SSR Only': SSRPass.OUTPUT.SSR,
          Beauty: SSRPass.OUTPUT.Beauty,
          Depth: SSRPass.OUTPUT.Depth,
          Normal: SSRPass.OUTPUT.Normal,
          Metalness: SSRPass.OUTPUT.Metalness,
        })
        .onChange(function (value) {
          ssrPass.output = parseInt(value);
        });

      groundReflector.opacity = ssrPass.opacity;
      folder
        .add(ssrPass, 'opacity')
        .min(0)
        .max(1)
        .onChange(() => {
          groundReflector.opacity = ssrPass.opacity;
        });
      folder.add(ssrPass, 'blur');
      gui.close();
    }

    function render() {
      requestAnimationFrame(render);
      time = clock.getElapsedTime();
      let analyser = player.analyser;
      if (analyser) {
        // each item represents decibel value for specific frequency
        // freqs go from 0 to 1/2 of the sample rate
        analyser.getByteFrequencyData(player.buffer);
        uniforms.uData.value = player.buffer;
      }

      // Update uniforms
      uniforms.uTime.value = time;

      if (settings.orbitControls) {
        controls.update();
      } else {
        camera.position.x +=
          (uniforms.uMouse.value.x - camera.position.x) * 0.05;
        camera.position.y +=
          (-uniforms.uMouse.value.y - camera.position.y) * 0.02 + 0.25;
        camera.lookAt(scene.position);
      }
      stats.begin();
      composer.render();
      stats.end();
    }

    function postProcessing() {
      renderScene = new RenderPass(scene, camera);
      bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        settings.bloomStrength,
        settings.bloomRadius,
        settings.bloomThreshold,
      );

      ssrPass = new SSRPass({
        renderer,
        scene,
        camera,
        width: window.innerWidth,
        height: window.innerHeight,
        groundReflector: settings.groundReflector ? groundReflector : null,
        selects: settings.groundReflector ? selects : null,
      });
      ssrPass.thickness = 0.018;
      ssrPass.maxDistance = 1.3;
      ssrPass.output = SSRPass.OUTPUT.Beauty;
      ssrPass.opacity = 0.8;

      composer.addPass(renderScene);
      composer.addPass(ssrPass);
      composer.addPass(bloomPass);
      // composer.addPass( new ShaderPass( RGBShiftShader ) );
    }

    init();
  };

  App();
</script>

<style is:global>
  html {
    height: 100vh;
    overflow: hidden;
  }
</style>

<style>
  body {
    width: 100%;
    height: 100vh;
    background: var(--color-background);
    overflow: hidden;
    overscroll-behavior: none;
    margin: 0;
    padding: 0;
  }

  #app_view {
    display: block;
    width: 100%;
    height: 100%;
  }

  #container {
    position: relative;
    width: 100%;
    height: 100%;
  }

  #gui_container {
    position: absolute;
    top: var(--header-height);
    left: 2rem;
  }

  #gui {
    position: absolute;
    top: 0;
    left: 0;
  }

  #player_container {
    display: inline-flex;
    flex-direction: column;
    position: absolute;
    bottom: 0;
    width: 100%;
    max-width: 400px;
    margin-bottom: 1rem;
    left: 50%;
    transform: translateX(-50%);
    row-gap: 1rem;
  }

  #play_btn {
    position: absolute;
    width: 2rem;
    height: 2rem;
    bottom: 3px;
    left: calc(50% - 125px);
    transform: translateX(-50%);
    background: transparent;
    border: none;
    z-index: 99;
    cursor: pointer;
  }

  .controls {
    position: relative;
    z-index: 99;
    display: flex;
    flex-direction: column;
    row-gap: 2rem;
    transform: scale(0.9);
  }
</style>
