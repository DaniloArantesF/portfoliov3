---
import SceneLayout from 'src/layouts/SceneLayout.astro';
---

<SceneLayout title="SpaceJams" audio />

<script>
  import * as THREE from 'three';
  import BaseScene, { BaseSceneState, isReady } from '@lib/sceneController';
  import { loadGLTF } from '@lib/textureLoader';
  import Player from 'src/components/Player';
  import type { GLTF } from 'three/examples/jsm/loaders/GLTFLoader';
  import vertexShader from './shaders/vertex.vs.glsl?raw';
  import fragmentShader from './shaders/fragment.fs.glsl?raw';
  import bodyVertexShader from './shaders/body.vs.glsl?raw';
  import bodyFragmentShader from './shaders/body.fs.glsl?raw';
  import skyVertexShader from './shaders/sky.vs.glsl?raw';
  import skyFragmentShader from './shaders/sky.fs.glsl?raw';
  import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
  import { SSRPass } from 'three/examples/jsm/postprocessing/SSRPass';
  import { fibonacciSphereV3 } from '@utils/geometry';

  /* ---------------------------------------------- */
  /*                 Setup & Globals                */
  /* ---------------------------------------------- */
  const defaultCameraPosition = [0, 2, 2];
  const skyModeCameraPosition = [0, 4, 20];
  const customSettings = {
    skyMode: false,
    enableSSR: true,
    bloomStrength: 0.55,
    bloomThreshold: 0.3,
    bloomRadius: 0.6,
    starLayers: 3,
  };

  const canvas = document.getElementById('app_view')! as HTMLCanvasElement;
  const { state, registerRenderCallback, utils } = BaseScene({
    canvas,
    settings: { cameraPosition: defaultCameraPosition, far: 3000 },
  });
  const { scene, renderer, camera, composer, uniforms, orbitControls } = state;
  const { gui, resetCamera, updateSetting } = utils;

  // Load models
  interface Assets {
    rockColorMap: THREE.Texture;
    rockDisplacementMap: THREE.Texture;
    rockRoughnessMap: THREE.Texture;
    rockAoMap: THREE.Texture;
    rockNormalMap: THREE.Texture;
    model?: GLTF;
  }
  let assets = loadAssets();

  function loadAssets() {
    let assets: Assets = {
      rockColorMap: new THREE.TextureLoader().load(
        '/assets/textures/ground_color_1k.jpg',
      ),
      rockDisplacementMap: new THREE.TextureLoader().load(
        '/assets/textures/ground_height_1k.png',
      ),
      rockRoughnessMap: new THREE.TextureLoader().load(
        '/assets/textures/ground_roughness_1k.jpg',
      ),
      rockAoMap: new THREE.TextureLoader().load(
        '/assets/textures/ground_ao_1k.jpg',
      ),
      rockNormalMap: new THREE.TextureLoader().load(
        '/assets/textures/ground_normal_opengl_1k.png',
      ),
    };
    [
      assets.rockColorMap,
      assets.rockDisplacementMap,
      assets.rockRoughnessMap,
      assets.rockAoMap,
      assets.rockNormalMap,
    ].forEach((t) => {
      if (!(t instanceof THREE.Texture)) return;
      t.wrapS = THREE.RepeatWrapping;
      t.wrapT = THREE.RepeatWrapping;
      t.repeat.set(10, 10);
      t.encoding = THREE.sRGBEncoding;
    });

    loadGLTF('/assets/models/speaker.glb', function (model) {
      assets['model'] = model;
      Scene();
    });

    return assets as Assets;
  }

  /* ---------------------------------------------- */
  /*                      Scene                     */
  /* ---------------------------------------------- */
  function Scene() {
    /* ---------- Audio ---------- */
    let player = Player.getInstance();
    uniforms.uData = { value: player.buffer };
    uniforms.uStarLayerCount = { value: 3 };

    /* ---------- Scene ---------- */
    let speaker: THREE.Object3D, sky: THREE.Mesh;
    let rock: THREE.Mesh;
    let points: THREE.Points;

    /* ---------- Settings ---------- */
    function updateDefaultCameraPosition() {
      const [x, y, z] = customSettings.skyMode
        ? skyModeCameraPosition
        : defaultCameraPosition;
      updateSetting('cameraPosition', [x, y, z]);
      resetCamera();
    }
    updateDefaultCameraPosition();

    /* ---------- GUI ---------- */
    gui.addInput(customSettings, 'skyMode').on('change', () => {
      if (customSettings.skyMode) {
        orbitControls.enabled = false;
        updateSetting('orbitControls', false);
        gui.refresh();
      }
      updateDefaultCameraPosition();
    });

    /* ---------- Effects ---------- */
    function postProcessing() {
      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        customSettings.bloomStrength,
        customSettings.bloomRadius,
        customSettings.bloomThreshold,
      );

      const ssrPass = new SSRPass({
        renderer,
        scene,
        camera,
        width: window.innerWidth,
        height: window.innerHeight,
        groundReflector: null,
        selects: null,
      });
      ssrPass.thickness = 0.018;
      ssrPass.maxDistance = 0.1;
      ssrPass.output = SSRPass.OUTPUT.Beauty;
      ssrPass.opacity = 0.9;

      composer.addPass(ssrPass);
      composer.addPass(bloomPass);
    }
    postProcessing();

    /* ---------- Lights ---------- */
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambientLight);

    const spotLight = new THREE.SpotLight(0xffffff, 0.5);
    spotLight.angle = Math.PI / 4;
    spotLight.penumbra = 0.1;

    spotLight.castShadow = true;
    spotLight.position.set(-150, 75, 150);
    scene.add(spotLight);

    const spotLight2 = new THREE.SpotLight(0xaaaaaa, 0.8);
    spotLight2.position.set(10, 100, 200);
    spotLight2.castShadow = true;
    spotLight2.shadow.mapSize.width = 1024;
    spotLight2.shadow.mapSize.height = 1024;
    scene.add(spotLight2);

    /* ---------- Geometry ---------- */
    speaker = assets.model!.scene.children[0];
    rock = assets.model!.scene.children[1] as THREE.Mesh;
    speaker.rotateY(Math.PI / 2);
    rock.rotateY(-Math.PI / 2);
    rock.position.y += 0.01;
    rock.scale.x *= 0.75;
    rock.scale.z *= 0.75;

    let body = speaker.children[1] as THREE.Mesh;
    body.material = new THREE.ShaderMaterial({
      uniforms,
      vertexShader: bodyVertexShader,
      fragmentShader: bodyFragmentShader,
    });

    body.scale.multiply(new THREE.Vector3(1.01, 1.01, 1.01));
    speaker.castShadow = true;
    speaker.receiveShadow = true;
    scene.add(speaker);
    scene.add(rock);

    const skyGeometry = new THREE.IcosahedronGeometry(1000, 100);
    const skyMaterial = new THREE.ShaderMaterial({
      uniforms: uniforms,
      vertexShader: skyVertexShader,
      fragmentShader: skyFragmentShader,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      side: THREE.DoubleSide,
    });

    sky = new THREE.Mesh(skyGeometry, skyMaterial);
    sky.position.set(0, 0, -110);
    sky.rotation.y -= Math.PI / 2;
    scene.add(sky);

    const material = new THREE.ShaderMaterial({
      uniforms: uniforms,
      vertexShader,
      fragmentShader,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
    });

    const mesh = new THREE.Mesh(new THREE.SphereGeometry(32, 50, 50), material);

    mesh.scale.set(0.006, 0.003, 0.006);
    mesh.position.set(0.52, 0.28, -0.012);
    mesh.rotateZ(-Math.PI / 2);

    points = new THREE.Points(
      new THREE.BufferGeometry().setFromPoints(fibonacciSphereV3(10000, 32)),
      material,
    );

    points.scale.set(0.006, 0.003, 0.006);
    points.position.set(0.52, 0.28, -0.012);
    points.rotateZ(-Math.PI / 2);
    scene.add(points);

    const mesh2 = new THREE.Mesh(
      new THREE.SphereGeometry(32, 50, 50),
      material,
    );

    mesh2.scale.set(0.006, 0.003, 0.006);
    mesh2.position.set(-0.5, 0.28, -0.012);
    mesh2.rotateZ(Math.PI / 2);

    const points2 = new THREE.Points(
      new THREE.BufferGeometry().setFromPoints(fibonacciSphereV3(10000, 32)),
      material,
    );

    points2.scale.set(0.006, 0.003, 0.006);
    points2.position.set(-0.52, 0.28, -0.012);
    points2.rotateZ(Math.PI / 2);
    scene.add(points2);

    scene.add(mesh);
    scene.add(mesh2);

    rock.material = new THREE.MeshStandardMaterial({
      map: assets.rockColorMap,
      displacementBias: -0.5,
      normalMap: assets.rockNormalMap,
      roughnessMap: assets.rockRoughnessMap,
      aoMap: assets.rockAoMap,
    });

    function animationLoop(state: BaseSceneState) {
      let analyser = player.analyser;
      if (analyser) {
        // each item represents decibel value for specific frequency
        // freqs go from 0 to 1/2 of the sample rate
        analyser.getByteFrequencyData(player.buffer);
        uniforms.uData.value = player.buffer;
      }

      // Move camera
      if (!orbitControls.enabled) {
        camera.position.x +=
          (uniforms.uMouse.value.x / 10 - camera.position.x) * 0.03;
        camera.position.y +=
          (-uniforms.uMouse.value.y / 20 - camera.position.y + 0.5) * 0.1;
        camera.lookAt(scene.position);
      }
    }

    registerRenderCallback(animationLoop);
    isReady.set(true);
  }
</script>

<style>
  #player_container {
    display: inline-flex;
    flex-direction: column;
    position: absolute;
    bottom: 0;
    width: 100%;
    max-width: 400px;
    margin-bottom: 1rem;
    left: 50%;
    transform: translateX(-50%);
    row-gap: 1rem;
  }

  #play_btn {
    position: absolute;
    width: 2rem;
    height: 2rem;
    bottom: 3px;
    left: calc(50% - 125px);
    transform: translateX(-50%);
    background: transparent;
    border: none;
    z-index: 99;
    cursor: pointer;
  }

  .controls {
    position: relative;
    z-index: 99;
    display: flex;
    flex-direction: column;
    row-gap: 2rem;
    transform: scale(0.9);
  }
</style>
