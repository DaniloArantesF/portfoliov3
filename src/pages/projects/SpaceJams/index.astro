---
import { PlayerController } from '../../../components/PlayerController';
import StealthLayout from '../../../layouts/StealthLayout.astro';
---

<StealthLayout title="SpaceJams">
  <main id="container">
    <canvas id="app_view"></canvas>
    <div id="gui_container"><div id="loading-indicator"></div></div>
    <div id="player_container">
      <audio></audio>
      <div class="controls">
        <PlayerController client:only="react" />
      </div>
    </div>
  </main>
</StealthLayout>

<script>
  import * as THREE from 'three';
  import BaseScene, { BaseSceneState } from '@lib/sceneController';
  import { loadGLTF } from '@lib/textureLoader';
  import Player from 'src/components/Player';
  import type { GLTF } from 'three/examples/jsm/loaders/GLTFLoader';
  import vertexShader from './shaders/vertex.vs.glsl?raw';
  import fragmentShader from './shaders/fragment.fs.glsl?raw';
  import bodyVertexShader from './shaders/body.vs.glsl?raw';
  import bodyFragmentShader from './shaders/body.fs.glsl?raw';
  import skyVertexShader from './shaders/sky.vs.glsl?raw';
  import skyFragmentShader from './shaders/sky.fs.glsl?raw';
  import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
  import { SSRPass } from 'three/examples/jsm/postprocessing/SSRPass';

  import { fibonacciSphereV3 } from '@utils/geometry';

  const canvas = document.getElementById('app_view')! as HTMLCanvasElement;

  // Init scene
  const { state, registerAnimationCallback, utils } = BaseScene({ canvas });
  const { scene, renderer, camera, composer, uniforms, orbitControls } = state;

  const { gui, resetCamera, setDefaultCameraPosition } = utils;

  const customSettings = {
    cameraPosition: [0, 2, 2],
    skyModeCameraPosition: [0, 4, 20],
    skyMode: false,
    far: 3000,
    enableSSR: true,
    bloomStrength: 0.55,
    bloomThreshold: 0.3,
    bloomRadius: 0.6,
    starLayers: 3,
  };

  // Load models
  interface Assets {
    rockColorMap: THREE.Texture;
    rockDisplacementMap: THREE.Texture;
    rockRoughnessMap: THREE.Texture;
    rockAoMap: THREE.Texture;
    rockNormalMap: THREE.Texture;
    model?: GLTF;
  }
  let assets = loadAssets();

  function loadAssets() {
    let assets: Assets = {
      rockColorMap: new THREE.TextureLoader().load(
        '/assets/textures/ground_color_1k.jpg',
      ),
      rockDisplacementMap: new THREE.TextureLoader().load(
        '/assets/textures/ground_height_1k.png',
      ),
      rockRoughnessMap: new THREE.TextureLoader().load(
        '/assets/textures/ground_roughness_1k.jpg',
      ),
      rockAoMap: new THREE.TextureLoader().load(
        '/assets/textures/ground_ao_1k.jpg',
      ),
      rockNormalMap: new THREE.TextureLoader().load(
        '/assets/textures/ground_normal_opengl_1k.png',
      ),
    };
    [
      assets.rockColorMap,
      assets.rockDisplacementMap,
      assets.rockRoughnessMap,
      assets.rockAoMap,
      assets.rockNormalMap,
    ].forEach((t) => {
      if (!(t instanceof THREE.Texture)) return;
      t.wrapS = THREE.RepeatWrapping;
      t.wrapT = THREE.RepeatWrapping;
      t.repeat.set(10, 10);
      t.encoding = THREE.sRGBEncoding;
    });

    loadGLTF('/assets/models/speaker.glb', function (model) {
      assets['model'] = model;
      Scene();
    });

    return assets as Assets;
  }

  function Scene() {
    /* ---------------------------------------------- */
    /*                      Audio                     */
    /* ---------------------------------------------- */
    let player = Player.getInstance();
    uniforms.uData = { type: `uint[128]`, value: player.buffer };
    uniforms.uStarLayerCount = { type: `f`, value: 3 };

    /* ---------------------------------------------- */
    /*                      Scene                     */
    /* ---------------------------------------------- */
    let speaker: THREE.Object3D, sky: THREE.Mesh;
    let rock: THREE.Mesh;
    let points: THREE.Points;

    /* ---------- Settings ---------- */
    function updateDefaultCameraPosition() {
      const [x, y, z] = customSettings.skyMode
        ? customSettings.skyModeCameraPosition
        : customSettings.cameraPosition;
      setDefaultCameraPosition(x, y, z);
      resetCamera();
    }
    updateDefaultCameraPosition();

    /* ---------- GUI ---------- */
    gui.addInput(customSettings, 'skyMode').on('change', () => {
      if (customSettings.skyMode) {
        orbitControls.enabled = false;
        // TODO: set property in base settings and update ui
      }
      updateDefaultCameraPosition();
    });

    /* ---------- Effects ---------- */
    function postProcessing() {
      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        customSettings.bloomStrength,
        customSettings.bloomRadius,
        customSettings.bloomThreshold,
      );

      const ssrPass = new SSRPass({
        renderer,
        scene,
        camera,
        width: window.innerWidth,
        height: window.innerHeight,
        groundReflector: null,
        selects: null,
      });
      ssrPass.thickness = 0.018;
      ssrPass.maxDistance = 0.1;
      ssrPass.output = SSRPass.OUTPUT.Beauty;
      ssrPass.opacity = 0.9;

      composer.addPass(ssrPass);
      composer.addPass(bloomPass);
    }
    postProcessing();

    /* ---------- Lights ---------- */
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambientLight);

    const spotLight = new THREE.SpotLight(0xffffff, 0.5);
    spotLight.angle = Math.PI / 4;
    spotLight.penumbra = 0.1;

    spotLight.castShadow = true;
    spotLight.position.set(-150, 75, 150);
    scene.add(spotLight);

    const spotLight2 = new THREE.SpotLight(0xaaaaaa, 0.8);
    spotLight2.position.set(10, 100, 200);
    spotLight2.castShadow = true;
    spotLight2.shadow.mapSize.width = 1024;
    spotLight2.shadow.mapSize.height = 1024;
    scene.add(spotLight2);

    /* ---------- Geometry ---------- */
    speaker = assets.model!.scene.children[0];
    rock = assets.model!.scene.children[1] as THREE.Mesh;
    speaker.rotateY(Math.PI / 2);
    rock.rotateY(-Math.PI / 2);
    rock.position.y += 0.01;
    rock.scale.x *= 0.75;
    rock.scale.z *= 0.75;
    // selects.push(speaker);
    // selects.push(rock);

    let body = speaker.children[1] as THREE.Mesh;
    body.material = new THREE.ShaderMaterial({
      uniforms,
      vertexShader: bodyVertexShader,
      fragmentShader: bodyFragmentShader,
    });

    body.scale.multiply(new THREE.Vector3(1.01, 1.01, 1.01));
    speaker.castShadow = true;
    speaker.receiveShadow = true;
    scene.add(speaker);
    scene.add(rock);

    const skyGeometry = new THREE.IcosahedronGeometry(1000, 100);
    const skyMaterial = new THREE.ShaderMaterial({
      uniforms: uniforms,
      vertexShader: skyVertexShader,
      fragmentShader: skyFragmentShader,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      side: THREE.DoubleSide,
    });

    sky = new THREE.Mesh(skyGeometry, skyMaterial);
    sky.position.set(0, 0, -110);
    sky.rotation.y -= Math.PI / 2;
    scene.add(sky);
    // selects.push(sky);

    const material = new THREE.ShaderMaterial({
      uniforms: uniforms,
      vertexShader,
      fragmentShader,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
    });

    const mesh = new THREE.Mesh(new THREE.SphereGeometry(32, 50, 50), material);

    mesh.scale.set(0.006, 0.003, 0.006);
    mesh.position.set(0.52, 0.28, -0.012);
    mesh.rotateZ(-Math.PI / 2);

    points = new THREE.Points(
      new THREE.BufferGeometry().setFromPoints(fibonacciSphereV3(10000, 32)),
      material,
    );

    points.scale.set(0.006, 0.003, 0.006);
    points.position.set(0.52, 0.28, -0.012);
    points.rotateZ(-Math.PI / 2);
    scene.add(points);

    const mesh2 = new THREE.Mesh(
      new THREE.SphereGeometry(32, 50, 50),
      material,
    );

    mesh2.scale.set(0.006, 0.003, 0.006);
    mesh2.position.set(-0.5, 0.28, -0.012);
    mesh2.rotateZ(Math.PI / 2);

    const points2 = new THREE.Points(
      new THREE.BufferGeometry().setFromPoints(fibonacciSphereV3(10000, 32)),
      material,
    );

    points2.scale.set(0.006, 0.003, 0.006);
    points2.position.set(-0.52, 0.28, -0.012);
    points2.rotateZ(Math.PI / 2);
    scene.add(points2);

    scene.add(mesh);
    scene.add(mesh2);
    // selects.push(mesh);
    // selects.push(mesh2);

    rock.material = new THREE.MeshStandardMaterial({
      map: assets.rockColorMap,
      displacementBias: -0.5,
      normalMap: assets.rockNormalMap,
      roughnessMap: assets.rockRoughnessMap,
      aoMap: assets.rockAoMap,
    });

    function animationLoop(state: BaseSceneState) {
      let analyser = player.analyser;
      if (analyser) {
        // each item represents decibel value for specific frequency
        // freqs go from 0 to 1/2 of the sample rate
        analyser.getByteFrequencyData(player.buffer);
        uniforms.uData.value = player.buffer;
      }

      // Move camera
      if (!orbitControls.enabled) {
        camera.position.x +=
          (uniforms.uMouse.value.x / 10 - camera.position.x) * 0.03;
        camera.position.y +=
          (-uniforms.uMouse.value.y / 20 - camera.position.y + 0.5) * 0.1;
        camera.lookAt(scene.position);
      }
    }

    registerAnimationCallback(animationLoop);
  }
</script>

<style is:global>
  html {
    height: 100vh;
    overflow: hidden;
  }
</style>

<style>
  body {
    width: 100%;
    height: 100vh;
    background: var(--color-background);
    overflow: hidden;
    overscroll-behavior: none;
    margin: 0;
    padding: 0;
  }

  #app_view {
    display: block;
    width: 100%;
    height: 100%;
  }

  #container {
    position: relative;
    width: 100%;
    height: 100%;
  }

  #gui_container {
    position: absolute;
    top: var(--header-height);
    left: 2rem;
  }

  #gui {
    position: absolute;
    top: 0;
    left: 0;
  }

  #player_container {
    display: inline-flex;
    flex-direction: column;
    position: absolute;
    bottom: 0;
    width: 100%;
    max-width: 400px;
    margin-bottom: 1rem;
    left: 50%;
    transform: translateX(-50%);
    row-gap: 1rem;
  }

  #play_btn {
    position: absolute;
    width: 2rem;
    height: 2rem;
    bottom: 3px;
    left: calc(50% - 125px);
    transform: translateX(-50%);
    background: transparent;
    border: none;
    z-index: 99;
    cursor: pointer;
  }

  .controls {
    position: relative;
    z-index: 99;
    display: flex;
    flex-direction: column;
    row-gap: 2rem;
    transform: scale(0.9);
  }
</style>
