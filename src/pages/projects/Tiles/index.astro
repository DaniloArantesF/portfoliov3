---
import SceneLayout from 'src/layouts/SceneLayout.astro';
---

<SceneLayout title="Tiles" />

<script>
  import * as THREE from 'three';
  import BaseScene, { BaseSceneState, isReady } from '@lib/sceneController';
  import { clamp, curve, range } from '@utils/math';
  import { Observer } from 'gsap/Observer';
  import gsap from 'gsap';
  import imageFragmentShader from './shaders/image.fs.glsl?raw';
  import imageVertexShader from './shaders/image.vs.glsl?raw';
  import Minimap from '@lib/components/Minimap';
  const damp = THREE.MathUtils.damp;

  // 0 means first picture is all the way to the left
  let scrollPosition = 0;
  const canvas = document.getElementById('app_view')! as HTMLCanvasElement;
  const { state, registerAnimationCallback, utils } = BaseScene({ canvas });
  const { scene, renderer, camera, uniforms } = state;
  utils.setDefaultCameraPosition(0, 0, 1.25);
  utils.resetCamera();

  type ImageProps = Partial<Omit<THREE.Mesh, 'scale'>> & {
    scale?: THREE.Vector3;
    color?: THREE.Color;
    zoom?: number;
    grayscale?: number;
    url: string;
    uniforms: any;
  };

  const Image: (props: ImageProps) => THREE.Mesh = ({
    url,
    uniforms,
    position = new THREE.Vector3(0, 0, 0),
    scale = new THREE.Vector3(0.3, 1, 1),
    color = new THREE.Color(255, 255, 255),
    zoom = 1,
    grayscale = 0,
  }) => {
    const imageSize = new THREE.Vector2(4, 3); // TODO: improve this
    const texture = new THREE.TextureLoader().load(url);
    const geometry = new THREE.PlaneGeometry(1, 1, 5, 5);

    // texture encoding?
    const material = new THREE.ShaderMaterial({
      vertexShader: imageVertexShader,
      fragmentShader: imageFragmentShader,
      uniforms: {
        ...uniforms,
        imageSize: { value: imageSize },
        color: { value: color },
        zoom: { value: zoom },
        grayscale: { value: grayscale },
        opacity: { value: 1 },
        map: {
          value: texture,
        },
      },
      side: THREE.DoubleSide,
      transparent: true,
    });

    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.copy(position);
    mesh.scale.copy(scale);

    return mesh;
  };

  interface GalleryProps {
    pictures: { src: string }[];
    uniforms: any;
    tileWidth: number;
    gap: number;
  }

  const Gallery = ({ pictures, uniforms, tileWidth, gap }: GalleryProps) => {
    const galleryGroup = new THREE.Group();
    const minimap = Minimap({ count: pictures.length });
    const { width: viewWidth } = utils.getViewport();
    const tiles: { scale: THREE.Vector3 }[] = [];
    const totalTileWidth = tileWidth + gap;

    const pages =
      (viewWidth - totalTileWidth + pictures.length * totalTileWidth) /
      viewWidth;

    // Handle scroll
    // TODO: refine this
    gsap.registerPlugin(Observer);
    Observer.create({
      type: 'wheel, touch, pointer',
      onDown: ({ deltaY }) => {
        scrollPosition += deltaY / 1500;
      },
      onUp: ({ deltaY }) => {
        scrollPosition += deltaY / 1500;
      },
      onDrag: (event) => {
        scrollPosition -= event.deltaX / 3000;
      },
      tolerance: 50,
    });

    console.log(viewWidth);
    for (let i = 0; i < pictures.length; i++) {
      let position = new THREE.Vector3(i * totalTileWidth, 0, 0);
      tiles.push({ scale: new THREE.Vector3(tileWidth, 1, 1) });

      galleryGroup.add(
        Image({
          url: pictures[i].src,
          uniforms: {
            ...uniforms,
            scale: { value: tiles[i].scale },
          },
          position,
          scale: tiles[i].scale,
        }),
      );
    }

    function animationCallback(state: BaseSceneState) {
      scrollPosition = clamp(scrollPosition, 0, 1);

      for (let i = 0; i < galleryGroup.children.length; i++) {
        let picture = galleryGroup.children[i];
        let y = curve(
          i / pictures.length - 1.5 / pictures.length,
          4 / pictures.length,
          0,
          scrollPosition,
        );

        // Offset images based on scroll position
        picture.position.x = damp(
          picture.position.x,
          (i - scrollPosition * (pictures.length - 1)) * totalTileWidth,
          100,
          0.1,
        );

        // Vertical scaling
        let scaleY = damp(picture.scale.y, 1 + y / 4, 50, 0.1);
        picture.scale.y = scaleY;
        tiles[i].scale.y = scaleY;
      }

      // Update minimap
      minimap.children.forEach((line, i) => {
        const y = curve(
          i / minimap.children.length - 1.5 / minimap.children.length,
          4 / minimap.children.length,
          0,
          scrollPosition,
        );
        line.scale.y = Math.max(0.5, y);
      });
    }

    registerAnimationCallback(animationCallback);
    return { gallery: galleryGroup, minimap };
  };

  /* ---------- Geometry ---------- */
  const pictures = [
    { src: '/assets/projects/benji-demo-1.webp' },
    { src: '/assets/projects/3d-audio-visualizer-demo-1.webp' },
    { src: '/assets/projects/stacks-demo-1.webp' },
    { src: '/assets/projects/benji-demo-1.webp' },
    { src: '/assets/projects/stacks-demo-1.webp' },
  ];

  const tileWidth = 0.3,
    tileGap = 0.025;

  const { gallery, minimap } = Gallery({
    pictures,
    uniforms,
    tileWidth,
    gap: tileGap,
  });
  scene.add(gallery);
  scene.add(minimap);

  function animationLoop(state: BaseSceneState) {}

  isReady.set(true);
  registerAnimationCallback(animationLoop);
</script>

<style is:global>
  html {
    height: 100vh;
    overflow: hidden;
  }
</style>

<style>
  body {
    width: 100%;
    height: 100vh;
    background: var(--color-background);
    overflow: hidden;
    overscroll-behavior: none;
    margin: 0;
    padding: 0;
    position: relative;
  }

  #app_view {
    display: block;
    position: relative;
    z-index: 99;
    width: 100%;
    height: 100%;
  }

  #scroll-container {
    display: inline-block;
    position: absolute;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100%;
    overflow-y: hidden;
    overflow-x: scroll;
    z-index: 100;
  }

  #scroll-container::before {
    content: '';
    display: inline-block;
    width: 200vw;
  }

  #container {
    position: relative;
    width: 100%;
    height: 100%;
  }

  #gui_container {
    position: absolute;
    top: var(--header-height);
    left: 2rem;
  }

  #gui {
    position: absolute;
    top: 0;
    left: 0;
  }

  #player_container {
    display: inline-flex;
    flex-direction: column;
    position: absolute;
    bottom: 0;
    width: 100%;
    max-width: 400px;
    margin-bottom: 1rem;
    left: 50%;
    transform: translateX(-50%);
    row-gap: 1rem;
  }

  #play_btn {
    position: absolute;
    width: 2rem;
    height: 2rem;
    bottom: 3px;
    left: calc(50% - 125px);
    transform: translateX(-50%);
    background: transparent;
    border: none;
    z-index: 99;
    cursor: pointer;
  }

  .controls {
    position: relative;
    z-index: 99;
    display: flex;
    flex-direction: column;
    row-gap: 2rem;
    transform: scale(0.9);
  }
</style>
