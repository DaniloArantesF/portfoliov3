---
import SceneLayout from 'src/layouts/SceneLayout.astro';
---

<SceneLayout title="Globe" audio />

<script>
  import * as THREE from 'three';
  import BaseScene, { BaseSceneState, isReady } from '@lib/sceneController';
  import vertexShader from './shaders/vertex.vs.glsl?raw';
  import fragmentShader from './shaders/fragment.fs.glsl?raw';
  import globePassVertexShader from './shaders/globePass.vs.glsl?raw';
  import globePassFragmentShader from './shaders/globePass.fs.glsl?raw';
  import { usePlayer } from 'src/components/Player';
  import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass';
  import { fibonacciSphereV3 } from '@utils/geometry';

  /* ---------------------------------------------- */
  /*                 Setup & Globals                */
  /* ---------------------------------------------- */
  const canvas = document.getElementById('app_view')! as HTMLCanvasElement;
  const { state, registerRenderCallback, utils, setSceneHook } = BaseScene({
    canvas,
    settings: { orbitControls: true },
  });
  const { scene, camera, uniforms, composer } = state;
  const { gui } = utils;

  const effectSettings = {
    uActive:false,
    uProgress: 1,
    uScale: 1.3,
    uPower: 10,
    uSize: 0.13,
  };

  /* ---------------------------------------------- */
  /*                       Scene                    */
  /* ---------------------------------------------- */
  function Scene() {
    let globePass: ShaderPass;

    /* ---------- Audio ---------- */
    let player = usePlayer.get();
    uniforms.uData = { value: player.buffer };

    /* ---------- Geometry  ---------- */
    const material = new THREE.ShaderMaterial({
      uniforms,
      vertexShader,
      fragmentShader,
      side: THREE.DoubleSide,
    });

    const points = new THREE.Points(
      new THREE.BufferGeometry().setFromPoints(fibonacciSphereV3(1000, 32)),
      material,
    );

    function calculateZ(
      targetZ: number,
      targetHeight1 = window.innerHeight / 8,
      targetHeight2 = window.innerHeight / 2,
    ) {
      let vFOV = (camera.fov * Math.PI) / 180;

      // calculate height of viewport as seen from camera position
      let vHeightPartial = 2 * Math.tan(vFOV / 2);

      var p1 = targetHeight1 * window.innerHeight;
      var p2 = targetZ * vHeightPartial;
      var p3 = targetHeight2 * vHeightPartial;
      var p4 = targetHeight2 * p2;
      var p5 = p1 + p4;
      var z = p5 / p3;
      return z;
    }

    function animationLoop(state: BaseSceneState) {
      if (player) {
        let analyser = player.analyser;
        analyser?.getByteFrequencyData(player.buffer);
        uniforms.uData.value = player.buffer;
      }

      // Update uniforms
      globePass.uniforms.uTime.value = uniforms.uTime.value;
    }

    function initGUI() {
      gui
        .addInput(effectSettings, 'uScale', { min: -5, max: 10, step: 0.01 })
        .on(
          'change',
          () => (globePass.uniforms.uScale.value = effectSettings.uScale),
        );
      gui
        .addInput(effectSettings, 'uPower', { min: -5, max: 50, step: 0.01 })
        .on(
          'change',
          () => (globePass.uniforms.uPower.value = effectSettings.uPower),
        );
      gui
        .addInput(effectSettings, 'uSize', { min: -2, max: 5, step: 0.01 })
        .on(
          'change',
          () => (globePass.uniforms.uSize.value = effectSettings.uSize),
        );
      gui
        .addInput(effectSettings, 'uProgress', { min: 0, max: 1, step: 0.01 })
        .on(
          'change',
          () => (globePass.uniforms.uProgress.value = effectSettings.uProgress),
        );
      gui
        .addInput(effectSettings, 'uActive')
        .on(
          'change',
          () => (globePass.uniforms.uActive.value = effectSettings.uActive),
        );
    }

    function postProcessing() {
      globePass = new ShaderPass({
        uniforms: {
          ...uniforms,
          tDiffuse: { value: null },
          uBackgroundColor: { value: new THREE.Color(0x090c1b) },
          uProgress: { value: effectSettings.uProgress },
          uScale: { value: effectSettings.uScale },
          uPower: { value: effectSettings.uPower },
          uSize: { value: effectSettings.uSize },
          uActive: { value: effectSettings.uActive },
        },
        vertexShader: globePassVertexShader,
        fragmentShader: globePassFragmentShader,
      });

      composer.addPass(globePass);

      // Handle resize
      setSceneHook('onResize', () => {
        globePass.uniforms.uResolution.value = new THREE.Vector2(
          window.innerWidth,
          window.innerHeight,
        );

        utils.updateSetting('cameraPosition', [0, 0, calculateZ(0)]);
        utils.resetCamera();
      });
    }

    // Set default camera position
    utils.updateSetting('cameraPosition', [0, 0, calculateZ(0)]);
    utils.resetCamera();

    postProcessing();
    initGUI();
    scene.add(points);

    registerRenderCallback(animationLoop);
    isReady.set(true);
  }

  Scene();
</script>

<style>

</style>
