---
import SceneLayout from 'src/layouts/SceneLayout.astro';
import { PlayerController } from '../../../components/PlayerController';
---

<SceneLayout title="SpaceJams">
  <div id="player_container">
    <audio src="/assets/songs/song1.mp3" preload=""></audio>
    <div class="controls">
      <PlayerController client:only="react" />
    </div>
  </div>
</SceneLayout>

<script>
  import * as THREE from 'three';
  import BaseScene, { BaseSceneState, isReady } from '@lib/sceneController';
  import vertexShader from './shaders/vertex.vs.glsl?raw';
  import fragmentShader from './shaders/fragment.fs.glsl?raw';
  import globePassVertexShader from './shaders/globePass.vs.glsl?raw';
  import globePassFragmentShader from './shaders/globePass.fs.glsl?raw';
  import Player from 'src/components/Player';
  import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass';

  /* ---------------------------------------------- */
  /*                 Setup & Globals                */
  /* ---------------------------------------------- */
  const canvas = document.getElementById('app_view')! as HTMLCanvasElement;
  const { state, registerRenderCallback, utils } = BaseScene({
    canvas,
    settings: { cameraPosition: [0, 0, 0], orbitControls: true },
  });
  const { scene, camera, uniforms, composer } = state;
  const { gui } = utils;

  const effectSettings = {
    uActive: true,
    uProgress: 1,
    uScale: 2,
    uPower: 10,
    uSize: 0.17,
  };

  // Set default camera position
  utils.updateSetting('cameraPosition', [0, 0, calculateZ(0, 100, 400)]);
  utils.resetCamera();

  /* ---------------------------------------------- */
  /*                       Scene                    */
  /* ---------------------------------------------- */
  function Scene() {
    let globePass: ShaderPass;

    /* ---------- Audio ---------- */
    let player = Player.getInstance();
    uniforms.uData = { value: player.buffer };

    /* ---------- Geometry  ---------- */
    const plane = new THREE.Mesh(
      new THREE.PlaneGeometry(100, 100, 10, 10),
      new THREE.ShaderMaterial({
        uniforms,
        vertexShader,
        fragmentShader,
        side: THREE.DoubleSide,
      }),
    );

    function animationLoop(state: BaseSceneState) {
      if (player) {
        let analyser = player.analyser;
        analyser?.getByteFrequencyData(player.buffer);
        uniforms.uData.value = player.buffer;
      }
    }

    function postProcessing() {
      globePass = new ShaderPass({
        uniforms: {
          ...uniforms,
          tDiffuse: { value: null },
          uBackgroundColor: { value: new THREE.Color(0x090c1b) },
          uProgress: { value: effectSettings.uProgress },
          uScale: { value: effectSettings.uScale },
          uPower: { value: effectSettings.uPower },
          uSize: { value: effectSettings.uSize },
          uActive: { value: effectSettings.uActive },
        },
        vertexShader: globePassVertexShader,
        fragmentShader: globePassFragmentShader,
      });

      gui
        .addInput(effectSettings, 'uScale', { min: 0, max: 10, step: 0.01 })
        .on(
          'change',
          () => (globePass.uniforms.uScale.value = effectSettings.uScale),
        );
      gui
        .addInput(effectSettings, 'uPower', { min: 0, max: 50, step: 0.01 })
        .on(
          'change',
          () => (globePass.uniforms.uPower.value = effectSettings.uPower),
        );
      gui
        .addInput(effectSettings, 'uSize', { min: -2, max: 5, step: 0.01 })
        .on(
          'change',
          () => (globePass.uniforms.uSize.value = effectSettings.uSize),
        );
      gui
        .addInput(effectSettings, 'uProgress', { min: 0, max: 1, step: 0.01 })
        .on(
          'change',
          () => (globePass.uniforms.uProgress.value = effectSettings.uProgress),
        );
      gui
        .addInput(effectSettings, 'uActive')
        .on(
          'change',
          () => (globePass.uniforms.uActive.value = effectSettings.uActive),
        );
      composer.addPass(globePass);
    }
    postProcessing();

    scene.add(plane);

    registerRenderCallback(animationLoop);
    isReady.set(true);
  }

  function calculateZ(
    targetZ: number,
    targetHeight1 = window.innerHeight / 8,
    targetHeight2 = window.innerHeight / 2,
  ) {
    let vFOV = (camera.fov * Math.PI) / 180;

    // calculate height of viewport as seen from camera position
    let vHeightPartial = 2 * Math.tan(vFOV / 2);

    var p1 = targetHeight1 * window.innerHeight;
    var p2 = targetZ * vHeightPartial;
    var p3 = targetHeight2 * vHeightPartial;
    var p4 = targetHeight2 * p2;
    var p5 = p1 + p4;
    var z = p5 / p3;
    return z;
  }

  // TODO: handle resize e.g. aspect & update camera z
  Scene();
</script>

<style>
  #player_container {
    display: inline-flex;
    flex-direction: column;
    position: absolute;
    bottom: 0;
    width: 100%;
    max-width: 400px;
    margin-bottom: 1rem;
    left: 50%;
    transform: translateX(-50%);
    row-gap: 1rem;
  }

  #play_btn {
    position: absolute;
    width: 2rem;
    height: 2rem;
    bottom: 3px;
    left: calc(50% - 125px);
    transform: translateX(-50%);
    background: transparent;
    border: none;
    z-index: 99;
    cursor: pointer;
  }

  .controls {
    position: relative;
    z-index: 99;
    display: flex;
    flex-direction: column;
    row-gap: 2rem;
    transform: scale(0.9);
  }
</style>
