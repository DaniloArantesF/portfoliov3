---
import SceneLayout from 'src/layouts/SceneLayout.astro';

const title = 'Shells';
---

<SceneLayout title={title} />

<script>
  import * as THREE from 'three';
  import BaseScene, { isReady } from '@lib/sceneController';
  import vertexShader from './shaders/vertex.vs.glsl';
  import fragmentShader from './shaders/fragment.fs.glsl';
  import type { BaseSceneState } from '~/lib/types';
  import { toRadians } from '~/utils/math';

  /* -------------------------------- */
  /*          Setup & Globals         */
  /* -------------------------------- */
  const settings = {
    cameraPosition: [0, 3.75, 3.25],
    bloomStrength: 1.5,
    bloomThreshold: 0.1,
    bloomRadius: 0.1,
    gravity: new THREE.Vector3(0.0, -0.25, 0),
    gravityMultiplier: 2.5,
    shellCount: 256,
  };

  const canvas = document.getElementById('app-view')! as HTMLCanvasElement;
  const { state, registerRenderCallback, setSceneHook, utils } = BaseScene({
    canvas,
    settings: {
      orbitControls: false,
      cameraPosition: settings.cameraPosition,
      antialias: true,
    },
  });
  const { scene, camera, renderer, composer } = state;

  /* -------------------------------- */
  /*                Scene             */
  /* -------------------------------- */
  function Scene() {
    let mesh: THREE.Mesh,
      material: THREE.ShaderMaterial,
      geometry: THREE.BufferGeometry;

    let group: THREE.Group;

    const uniforms = {
      hairMap: { value: null as null | THREE.Texture },
      spacing: { value: 1.0 },
      gravityMultiplier: { value: settings.gravityMultiplier },
      gravity: { value: settings.gravity },
      ...state.uniforms,
    };

    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let shells: THREE.Mesh[] = [];

    function updateGravityForShells() {
      shells.forEach((shell) => {
        if (shell.material instanceof THREE.ShaderMaterial) {
          const localGravity = settings.gravity.clone();
          shell.worldToLocal(localGravity);
          shell.material.uniforms.gravity.value = localGravity;
        }
      });
    }

    function handleEvents() {
      document.addEventListener('mousedown', () => {
        isDragging = true;
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
      });

      document.addEventListener('mousemove', (e) => {
        let deltaMove = {
          x: e.offsetX - previousMousePosition.x,
          y: e.offsetY - previousMousePosition.y,
        };

        if (isDragging) {
          let deltaRotationQuaternion = new THREE.Quaternion().setFromEuler(
            new THREE.Euler(
              toRadians(deltaMove.y * 1),
              toRadians(deltaMove.x * 1),
              0,
              'XYZ',
            ),
          );

          group.quaternion.multiplyQuaternions(
            deltaRotationQuaternion,
            group.quaternion,
          );

          updateGravityForShells();
        }
        previousMousePosition = {
          x: e.offsetX,
          y: e.offsetY,
        };
      });

      // Handle resize
      setSceneHook('onResize', () => {
        const resolution = new THREE.Vector2(
          window.innerWidth,
          window.innerHeight,
        );
        utils.updateSetting('cameraPosition', settings.cameraPosition);
        utils.resetCamera();
      });
    }

    function animationLoop(state: BaseSceneState) {
      if (!state.orbitControls.enabled) {
        if (!state.orbitControls.enabled) {
          // camera.position.x +=
          //   (uniforms.uMouse.value.x / 10 - camera.position.x) * 1;
          // camera.position.y +=
          //   (-uniforms.uMouse.value.y / 15 - camera.position.y) * 1;
        }
      }
    }

    function init() {
      group = new THREE.Group();

      // Create hair property texture
      let canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      let context = canvas.getContext('2d')!;

      let strandCount = 30000;
      for (let i = 0; i < strandCount; i++) {
        let length = ~~(Math.random() * 255);

        let darkness = ~~(Math.random() * 255);
        let drawHair = true;
        context.fillStyle = `rgba(${
          drawHair ? '255' : '0'
        }, ${length}, ${darkness}, 1)`;

        context.fillRect(
          Math.random() * canvas.width,
          Math.random() * canvas.height,
          1,
          1,
        );
      }

      const hairPropertiesTexture = new THREE.CanvasTexture(canvas);
      uniforms.hairMap.value = hairPropertiesTexture;

      // geometry = new THREE.SphereGeometry(1, 10, 10);
      geometry = new THREE.TorusGeometry(2, 0.1, 20, 20);

      for (let i = 0; i < settings.shellCount; i++) {
        material = new THREE.ShaderMaterial({
          uniforms: {
            ...uniforms,
            offset: { value: i / settings.shellCount },
          },
          vertexShader,
          fragmentShader,
          side: THREE.DoubleSide,
          transparent: true,
          // wireframe: true
        });

        mesh = new THREE.Mesh(geometry, material);
        group.add(mesh);
        shells.push(mesh);
      }

      scene.add(group);

      handleEvents();
      registerRenderCallback(animationLoop);
      isReady.set(true);
    }

    function postProcessing() {}

    init();
  }

  Scene();
</script>
