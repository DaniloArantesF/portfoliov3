/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
author: ar-watches (https://sketchfab.com/ar-watches)
license: SKETCHFAB Editorial (https://sketchfab.com/licenses)
source: https://sketchfab.com/3d-models/rolex-yacht-master-watch-a0ab5e9b6d8d4f29b988bc9704991fdd
title: Rolex Yacht Master Watch
*/
import * as THREE from 'three';
import React, { useEffect, useRef } from 'react';
import { useGLTF } from '@react-three/drei';
import type { GLTF } from 'three-stdlib';
import { useFrame, useThree } from '@react-three/fiber';
import { Group } from 'three';
import { useDeviceOrientation } from '@lib/DeviceOrientation';

type GLTFResult = GLTF & {
  nodes: {
    calen_calend_0: THREE.Mesh;
    ['01_01_0']: THREE.Mesh;
    ['01_01_0_1']: THREE.Mesh;
    Shusha_Shush_0: THREE.Mesh;
    ['Object001_07_-_Default_0']: THREE.Mesh;
    num_white_white_0: THREE.Mesh;
    Object002_white_0: THREE.Mesh;
  };
  materials: {
    calend: THREE.MeshStandardMaterial;
    material: THREE.MeshStandardMaterial;
    Shush: THREE.MeshStandardMaterial;
    ['07_-_Default']: THREE.MeshStandardMaterial;
    white: THREE.MeshStandardMaterial;
  };
};

export function Model(props: React.JSX.IntrinsicElements['group']) {
  const { nodes, materials } = useGLTF(
    '/assets/models/watch.glb',
  ) as unknown as GLTFResult;
  const watchGroupRef = useRef<Group>(null);
  const deviceOrientation = useRef({
    alpha: 0,
    beta: 90,
    gamma: 0,
  });
  const initialOffset = useRef<number>(0);
  const alphaOffset = useRef<number>(0);
  const { camera } = useThree();
  const { setOrientation, permission, setPermission } = useDeviceOrientation();

  useEffect(() => {
    // Request permissions if IOS
    window.addEventListener('deviceorientation', handleOrientation, true);

    setOrientation(
      deviceOrientation.current.alpha,
      deviceOrientation.current.beta,
      deviceOrientation.current.gamma,
    );

    if (watchGroupRef.current) {
      watchGroupRef.current.rotation.order = 'ZXY';
    }
  }, []);

  function handleOrientation(event: DeviceOrientationEvent) {
    if (permission !== 1) {
      return;
    }

    if (!initialOffset.current) {
      initialOffset.current = event.alpha ?? 0;
    }

    let alpha =
      initialOffset.current === null
        ? (event.alpha ?? 0)
        : (event.alpha ?? 0) - initialOffset.current;

    if (alpha < 0) {
      alpha += 360;
    }

    console.log({ alpha, beta: event.beta, gamma: event.gamma });
    const beta = event.beta ?? 0;
    const gamma = event.gamma ?? 0;
    deviceOrientation.current = { alpha, beta, gamma };
    setOrientation(alpha, beta, gamma);
  }

  const setObjectQuaternion = (function () {
    const zee = new THREE.Vector3(0, 0, 1);
    const euler = new THREE.Euler();
    const q0 = new THREE.Quaternion();
    const q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); // - PI/2 around the x-axis
    return function (
      quaternion: THREE.Quaternion,
      alpha: number,
      beta: number,
      gamma: number,
      orient: number,
    ) {
      euler.set(beta, alpha, -gamma, 'YXZ'); // 'ZXY' for the device, but 'YXZ' for us
      quaternion.setFromEuler(euler); // orient the device
      quaternion.multiply(q1); // camera looks out the back of the device, not the top
      quaternion.multiply(q0.setFromAxisAngle(zee, -orient)); // adjust for screen orientation
    };
  })();

  useFrame((state) => {
    if (!watchGroupRef.current) return;

    const alpha = deviceOrientation.current.alpha
      ? THREE.MathUtils.degToRad(deviceOrientation.current.alpha)
      : 0; // Z
    const beta = deviceOrientation.current.beta
      ? THREE.MathUtils.degToRad(deviceOrientation.current.beta) +
        alphaOffset.current
      : 0; // X'
    const gamma = deviceOrientation.current.gamma
      ? THREE.MathUtils.degToRad(deviceOrientation.current.gamma)
      : 0; // Y''
    const orient = 0; // O
    setObjectQuaternion(
      watchGroupRef.current.quaternion,
      alpha + 0,
      beta,
      gamma,
      orient,
    );
  });

  return (
    <group
      receiveShadow
      castShadow
      position={[0, 0.05, 0]}
      scale={0.25}
      ref={watchGroupRef}
      {...props}
      dispose={null}
    >
      <group rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0.37, 0, 0.01]} rotation={[-Math.PI / 2, 0, 0]}>
            <mesh
              receiveShadow
              castShadow
              geometry={nodes.calen_calend_0.geometry}
              material={materials.calend}
            />
          </group>
          <group position={[0, 0.39, -2.18]} rotation={[-Math.PI / 2, 0, 0]}>
            <mesh
              receiveShadow
              castShadow
              geometry={nodes['01_01_0'].geometry}
              material={materials.material}
            />
            <mesh
              receiveShadow
              castShadow
              geometry={nodes['01_01_0_1'].geometry}
              material={materials.material}
            />
          </group>
          <group position={[0, 0, 0.09]} rotation={[-Math.PI / 2, 0, 0]}>
            <mesh
              receiveShadow
              castShadow
              geometry={nodes.Shusha_Shush_0.geometry}
              material={materials.Shush}
            />
          </group>
          <group position={[-0.36, 0.62, 0.1]} rotation={[-Math.PI / 2, 0, 0]}>
            <mesh
              receiveShadow
              castShadow
              geometry={nodes['Object001_07_-_Default_0'].geometry}
              material={materials['07_-_Default']}
            />
          </group>
          <group position={[0, 0, 0.03]} rotation={[-Math.PI / 2, 0, 0]}>
            <mesh
              receiveShadow
              castShadow
              geometry={nodes.num_white_white_0.geometry}
              material={materials.white}
            />
          </group>
          <group position={[0.01, 0, 0.05]} rotation={[-Math.PI / 2, 0, 0]}>
            <mesh
              receiveShadow
              castShadow
              geometry={nodes.Object002_white_0.geometry}
              material={materials.white}
            />
          </group>
        </group>
      </group>
    </group>
  );
}

useGLTF.preload('/assets/models/watch.glb');
